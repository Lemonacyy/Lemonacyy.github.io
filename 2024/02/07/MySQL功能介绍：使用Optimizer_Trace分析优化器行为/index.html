<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"lemonacyy.github.io","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="注：本文基于MySQL8.0.32，优化器使用CBO成本模型。 1 功能概述此优化器可以跟踪执行语句的解析、优化、执行的全过程，生成人类和程序可读的输出，以帮助理解 MySQL 优化器所采取的决策和操作。 2 使用方法在 MySQL 5.6 以及之后的版本中，MySQL提出了一个 optimizer trace 的功能，这个功能可以让我们方便的查看优化器生成执行计划的整个过程，这个功能的开启与关闭">
<meta property="og:type" content="article">
<meta property="og:title" content="MySQL功能介绍：使用Optimizer_Trace分析优化器行为">
<meta property="og:url" content="https://lemonacyy.github.io/2024/02/07/MySQL%E5%8A%9F%E8%83%BD%E4%BB%8B%E7%BB%8D%EF%BC%9A%E4%BD%BF%E7%94%A8Optimizer_Trace%E5%88%86%E6%9E%90%E4%BC%98%E5%8C%96%E5%99%A8%E8%A1%8C%E4%B8%BA/index.html">
<meta property="og:site_name" content="LEMONACY&#39;S HOUSE">
<meta property="og:description" content="注：本文基于MySQL8.0.32，优化器使用CBO成本模型。 1 功能概述此优化器可以跟踪执行语句的解析、优化、执行的全过程，生成人类和程序可读的输出，以帮助理解 MySQL 优化器所采取的决策和操作。 2 使用方法在 MySQL 5.6 以及之后的版本中，MySQL提出了一个 optimizer trace 的功能，这个功能可以让我们方便的查看优化器生成执行计划的整个过程，这个功能的开启与关闭">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-02-07T07:28:51.000Z">
<meta property="article:modified_time" content="2024-04-22T15:46:45.894Z">
<meta property="article:author" content="lemonacy">
<meta property="article:tag" content="MySQL">
<meta property="article:tag" content="功能介绍">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://lemonacyy.github.io/2024/02/07/MySQL%E5%8A%9F%E8%83%BD%E4%BB%8B%E7%BB%8D%EF%BC%9A%E4%BD%BF%E7%94%A8Optimizer_Trace%E5%88%86%E6%9E%90%E4%BC%98%E5%8C%96%E5%99%A8%E8%A1%8C%E4%B8%BA/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>MySQL功能介绍：使用Optimizer_Trace分析优化器行为 | LEMONACY'S HOUSE</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">LEMONACY'S HOUSE</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Make Lemons into Lemonade</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-日记">

    <a href="/diary/" rel="section"><i class="fa fa-archive fa-fw"></i>日记</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://lemonacyy.github.io/2024/02/07/MySQL%E5%8A%9F%E8%83%BD%E4%BB%8B%E7%BB%8D%EF%BC%9A%E4%BD%BF%E7%94%A8Optimizer_Trace%E5%88%86%E6%9E%90%E4%BC%98%E5%8C%96%E5%99%A8%E8%A1%8C%E4%B8%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.jpg">
      <meta itemprop="name" content="lemonacy">
      <meta itemprop="description" content="Make Lemons into Lemonade">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LEMONACY'S HOUSE">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          MySQL功能介绍：使用Optimizer_Trace分析优化器行为
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-02-07 15:28:51" itemprop="dateCreated datePublished" datetime="2024-02-07T15:28:51+08:00">2024-02-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-04-22 23:46:45" itemprop="dateModified" datetime="2024-04-22T23:46:45+08:00">2024-04-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MySQL/" itemprop="url" rel="index"><span itemprop="name">MySQL</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>注：本文基于MySQL8.0.32，优化器使用CBO成本模型。</p>
<h1 id="1-功能概述"><a href="#1-功能概述" class="headerlink" title="1 功能概述"></a>1 功能概述</h1><p>此优化器可以跟踪执行语句的解析、优化、执行的全过程，生成人类和程序可读的输出，以帮助理解 MySQL 优化器所采取的决策和操作。</p>
<h1 id="2-使用方法"><a href="#2-使用方法" class="headerlink" title="2 使用方法"></a>2 使用方法</h1><p>在 MySQL 5.6 以及之后的版本中，MySQL提出了一个 optimizer trace 的功能，这个功能可以让我们方便的查看优化器生成执行计划的整个过程，这个功能的开启与关闭由系统变量 optimizer_trace 决定：</p>
<span id="more"></span>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> <span class="keyword">global</span> variables <span class="keyword">like</span> <span class="string">&#x27;optimizer_trace&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+--------------------------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name   <span class="operator">|</span> <span class="keyword">Value</span>                    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+--------------------------+</span></span><br><span class="line"><span class="operator">|</span> optimizer_trace <span class="operator">|</span> enabled<span class="operator">=</span>off,one_line<span class="operator">=</span>off <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+--------------------------+</span></span><br></pre></td></tr></table></figure>

<p>这个功能默认是关闭的。</p>
<p>one_line控制输出格式，如果为 on 那么所有输出都将在一行中展示，不适合阅读，所以建议保持其默认值，即off。</p>
<p>优化器跟踪使用 JSON 格式。 它基本上是一个结构化日志文件，显示查询优化器采取了哪些操作。</p>
<p>每个连接都存储最后执行的语句的踪迹， 可以通过读取<code>information_schema.optimizer_trace</code>表来查看。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> information_schema.optimizer_trace\G</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">       <span class="keyword">Table</span>: OPTIMIZER_TRACE</span><br><span class="line"><span class="keyword">Create</span> <span class="keyword">Table</span>: <span class="keyword">CREATE</span> TEMPORARY <span class="keyword">TABLE</span> `OPTIMIZER_TRACE` (</span><br><span class="line">  `QUERY` longtext <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `TRACE` longtext <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `MISSING_BYTES_BEYOND_MAX_MEM_SIZE` <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span>,</span><br><span class="line">  `INSUFFICIENT_PRIVILEGES` tinyint <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span></span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb3</span><br></pre></td></tr></table></figure>

<p><code>information_schema.optimizer_trace</code>表包含四列：</p>
<ul>
<li>QUERY：执行的语句</li>
<li>TRACE：以JSON格式输出query执行时收集的统计信息</li>
<li>MISSING_BYTES_BEYOND_MAX_MEM_SIZE：如果踪迹比较大，记录会被截断，该列记录了缺少的字节数</li>
<li>INSUFFICIENT_PRIVILEGES：是否有权限查看执行计划的生成过程，0有权限，1无权限</li>
</ul>
<p>每个踪迹都使用字符串来储存，变量<code>optimizer_trace_max_mem_size</code>限制了当前踪迹的最大内存使用量，当内存使用达到该限制，当前的踪迹记录会不完整，<code>information_schema.optimizer_trace</code>表的<code>MISSING_BYTES_BEYOND_MAX_MEM_SIZE</code>列会写出踪迹缺少的字节数。</p>
<p>开启并使用optimizer trace：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SET</span> optimizer_trace<span class="operator">=</span>&quot;enabled=on&quot;;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">where</span> a<span class="operator">&lt;</span><span class="number">10</span>;</span><br><span class="line"><span class="keyword">Empty</span> <span class="keyword">set</span> (<span class="number">0.02</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> information_schema.optimizer_trace\G</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">                            QUERY: <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">where</span> a<span class="operator">&lt;</span><span class="number">10</span></span><br><span class="line">                            TRACE: &#123;</span><br><span class="line">  &quot;steps&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;join_preparation&quot;: &#123; ... &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;join_optimization&quot;: &#123;</span><br><span class="line">        &quot;select_id&quot;: <span class="number">1</span>,</span><br><span class="line">        &quot;steps&quot;: [</span><br><span class="line">          &#123; &quot;condition_processing&quot;: &#123; ... &#125; &#125;,</span><br><span class="line">          &#123; &quot;table_dependencies&quot;: [ ... ] &#125;,</span><br><span class="line">          &#123; &quot;ref_optimizer_key_uses&quot;: [ ... ] &#125;,</span><br><span class="line">          &#123; &quot;rows_estimation&quot;: [</span><br><span class="line">              &#123;</span><br><span class="line">                &quot;range_analysis&quot;: &#123;</span><br><span class="line">                   &quot;analyzing_range_alternatives&quot; : &#123; ... &#125;,</span><br><span class="line">                  &quot;chosen_range_access_summary&quot;: &#123; ... &#125;,</span><br><span class="line">                &#125;,</span><br><span class="line">                &quot;selectivity_for_indexes&quot; : &#123; ... &#125;,</span><br><span class="line">                &quot;selectivity_for_columns&quot; : &#123; ... &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            ]</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123; &quot;considered_execution_plans&quot;: [ ... ] &#125;,</span><br><span class="line">          &#123; &quot;attaching_conditions_to_tables&quot;: &#123; ... &#125; &#125;</span><br><span class="line">         ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;join_execution&quot;: &#123; ... &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line">MISSING_BYTES_BEYOND_MAX_MEM_SIZE: <span class="number">0</span></span><br><span class="line">          INSUFFICIENT_PRIVILEGES: <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>默认情况下，每个新跟踪都会覆盖以前的跟踪。 因此，如果语句包含子语句（例如：调用存储过程、存储函数、触发器），则顶部语句和子语句都会生成跟踪，但在执行结束时，只有最后一个子语句的跟踪可见。</p>
<blockquote>
<p>一般情况下，SELECT和EXPLAIN SELECT会产生同样的输出。但是如果涉及到子查询也有例外。例如：<br>SELECT … WHERE x IN (subq1) AND y IN (subq2)</p>
<p>如果第一个子查询的谓词IN固定为false，那么对第二个子查询就不会有jOIN::optimize()的优化；但是EXPLAIN SELECT会分析所有的子查询。</p>
</blockquote>
<h1 id="3-输出解读"><a href="#3-输出解读" class="headerlink" title="3 输出解读"></a>3 输出解读</h1><p>对于任何一个SELECT，优化过程都分为三个阶段：</p>
<ul>
<li><code>join_preparation</code>：展示了query的重写（rewrite），位于sql_resolver.cc 的 <code>Query_block::prepare()</code> 函数中，主要功能是解析 AST 上的各个 SQL 子句，同时也完成子查询相关的转换和优化，比如转换成 semi join，推导 table information，常量消除，冗余表达式消除等</li>
<li><code>join_optimization</code>：主要负责指令的优化，位于 sql_optimizer.cc 的 <code>JOIN::optimize()</code> 函数中，该函数包含了查询优化的主要逻辑，通过一系列逻辑等价的 query rewrite，cost based join optimization，rule-based access path selection 等优化步骤将 Query_block 优化成 query execution plan（QEP）</li>
<li><code>join_execution</code>：执行阶段，位于 sql_union.cc 的 <code>Query_expression::ExecuteIteratorQuery()</code> 函数中，主要负责查询执行<br>上述步骤仅适用于一个 SELECT。 如果查询有子查询，每个 SELECT 都会有这些步骤，并且会有额外的步骤&#x2F;重写来处理子查询构造本身。</li>
</ul>
<h2 id="3-1-join-preparation"><a href="#3-1-join-preparation" class="headerlink" title="3.1 join_preparation"></a>3.1 join_preparation</h2><p>在SQL的preparation阶段，主要是做语义解析、语法检测、永久性的基于规则的转换包括转换外连接成内连接、合并视图或者派生表和一些子查询转换。</p>
<p>几个典型的转换过程在trace中的体现：</p>
<h3 id="3-1-1-派生表合并"><a href="#3-1-1-派生表合并" class="headerlink" title="3.1.1 派生表合并"></a>3.1.1 派生表合并</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> (<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1) tt;</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> information_schema.optimizer_trace\G</span><br><span class="line">...</span><br><span class="line">            &quot;derived&quot;: &#123;</span><br><span class="line">              &quot;table&quot;: &quot;`` `tt`&quot;,</span><br><span class="line">              &quot;select#&quot;: <span class="number">2</span>,</span><br><span class="line">              &quot;merged&quot;: <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"># 变化为：</span><br><span class="line"># <span class="keyword">select</span> `t1`.`a` <span class="keyword">AS</span> `a` <span class="keyword">from</span> `t1`</span><br></pre></td></tr></table></figure>
<h3 id="3-1-2-标量子查询直接替代"><a href="#3-1-2-标量子查询直接替代" class="headerlink" title="3.1.2 标量子查询直接替代"></a>3.1.2 标量子查询直接替代</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">where</span> a <span class="operator">=</span> (<span class="keyword">select</span> <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> information_schema.optimizer_trace\G</span><br><span class="line">...</span><br><span class="line">            &quot;join_preparation&quot;: &#123;</span><br><span class="line">              &quot;select#&quot;: <span class="number">2</span>,</span><br><span class="line">              &quot;steps&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                  &quot;expanded_query&quot;: &quot;/* select#2 */ select 1&quot;</span><br><span class="line">                &#125;</span><br><span class="line">              ]</span><br><span class="line">            &#125;</span><br><span class="line">...</span><br><span class="line"># 变化为</span><br><span class="line"># <span class="comment">/* select#1 */</span> <span class="keyword">select</span> `t1`.`a` <span class="keyword">AS</span> `a` <span class="keyword">from</span> `t1` <span class="keyword">where</span> (`t1`.`a` <span class="operator">=</span> <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<h3 id="3-1-3-IN子查询变SEMI-JOIN"><a href="#3-1-3-IN子查询变SEMI-JOIN" class="headerlink" title="3.1.3 IN子查询变SEMI-JOIN"></a>3.1.3 IN子查询变SEMI-JOIN</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">where</span> a <span class="keyword">in</span> (<span class="keyword">select</span> a <span class="keyword">from</span> t2);</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> information_schema.optimizer_trace\G</span><br><span class="line">...</span><br><span class="line">            &quot;transformation&quot;: &#123;</span><br><span class="line">              &quot;select#&quot;: <span class="number">2</span>,</span><br><span class="line">              &quot;from&quot;: &quot;IN (SELECT)&quot;,</span><br><span class="line">              &quot;to&quot;: &quot;semijoin&quot;,</span><br><span class="line">              &quot;chosen&quot;: <span class="literal">true</span>,</span><br><span class="line">              &quot;transformation_to_semi_join&quot;: &#123;</span><br><span class="line">                &quot;subquery_predicate&quot;: &quot;`t1`.`a` in (/* select#2 */ select `t2`.`a` from `t2`)&quot;,</span><br><span class="line">                &quot;embedded in&quot;: &quot;WHERE&quot;,</span><br><span class="line">                &quot;semi-join condition&quot;: &quot;(`t1`.`a` = `t2`.`a`)&quot;,</span><br><span class="line">                &quot;decorrelated_predicates&quot;: [</span><br><span class="line">                  &#123;</span><br><span class="line">                    &quot;outer&quot;: &quot;`t1`.`a`&quot;,</span><br><span class="line">                    &quot;inner&quot;: &quot;`t2`.`a`&quot;</span><br><span class="line">                  &#125;</span><br><span class="line">                ]</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"># 变化为：</span><br><span class="line"># <span class="keyword">select</span> `t1`.`a` <span class="keyword">AS</span> `a` <span class="keyword">from</span> `t1` semi <span class="keyword">join</span> (`t2`) <span class="keyword">where</span> ((`t1`.`a` <span class="operator">=</span> `t2`.`a`))</span><br></pre></td></tr></table></figure>

<h3 id="3-1-4-EXISTS子查询变SEMI-JOIN"><a href="#3-1-4-EXISTS子查询变SEMI-JOIN" class="headerlink" title="3.1.4 EXISTS子查询变SEMI-JOIN"></a>3.1.4 EXISTS子查询变SEMI-JOIN</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> a, <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> t1_count <span class="keyword">from</span> t1 <span class="keyword">where</span> <span class="keyword">exists</span> (<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t2 <span class="keyword">where</span> a<span class="operator">=</span>b <span class="keyword">and</span> a <span class="operator">&lt;</span> c) <span class="keyword">group</span> <span class="keyword">by</span> a <span class="keyword">order</span> <span class="keyword">by</span> a;</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> information_schema.optimizer_trace\G</span><br><span class="line">...</span><br><span class="line">            &quot;transformation&quot;: &#123;</span><br><span class="line">              &quot;select#&quot;: <span class="number">2</span>,</span><br><span class="line">              &quot;from&quot;: &quot;IN (SELECT)&quot;,</span><br><span class="line">              &quot;to&quot;: &quot;semijoin&quot;,</span><br><span class="line">              &quot;chosen&quot;: <span class="literal">true</span>,</span><br><span class="line">              &quot;transformation_to_semi_join&quot;: &#123;</span><br><span class="line">                &quot;subquery_predicate&quot;: &quot;exists(/* select#2 */ select 1 from `t2` where ((`t2`.`a` = `t2`.`b`) and (`t2`.`a` &lt; `t2`.`c`)))&quot;,</span><br><span class="line">                &quot;embedded in&quot;: &quot;WHERE&quot;,</span><br><span class="line">                &quot;evaluating_constant_semijoin_conditions&quot;: [</span><br><span class="line">                ],</span><br><span class="line">                &quot;semi-join condition&quot;: &quot;((`t2`.`a` = `t2`.`b`) and (`t2`.`a` &lt; `t2`.`c`))&quot;,</span><br><span class="line">                &quot;decorrelated_predicates&quot;: [</span><br><span class="line">                  &#123;</span><br><span class="line">                    &quot;outer&quot;: &quot;1&quot;,</span><br><span class="line">                    &quot;inner&quot;: &quot;1&quot;</span><br><span class="line">                  &#125;</span><br><span class="line">                ]</span><br><span class="line">              &#125;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"># 变化为：</span><br><span class="line"># <span class="comment">/* select#1 */</span> <span class="keyword">select</span> `t1`.`a` <span class="keyword">AS</span> `a`,<span class="built_in">count</span>(<span class="number">0</span>) <span class="keyword">AS</span> `t1_count` <span class="keyword">from</span> `t1` semi <span class="keyword">join</span> (`t2`) <span class="keyword">where</span> ((`t2`.`a` <span class="operator">=</span> `t2`.`b`) <span class="keyword">and</span> (`t2`.`a` <span class="operator">&lt;</span> `t2`.`c`)) <span class="keyword">group</span> <span class="keyword">by</span> `t1`.`a` <span class="keyword">order</span> <span class="keyword">by</span> `t1`.`a`</span><br></pre></td></tr></table></figure>

<h3 id="3-1-5-子查询IN到EXISTS"><a href="#3-1-5-子查询IN到EXISTS" class="headerlink" title="3.1.5 子查询IN到EXISTS"></a>3.1.5 子查询IN到EXISTS</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">where</span> t1.b <span class="keyword">in</span> (<span class="keyword">select</span> <span class="built_in">sum</span>(a) <span class="keyword">from</span> t1);</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> information_schema.optimizer_trace\G</span><br><span class="line">...</span><br><span class="line">                  &quot;transformation&quot;: &#123;</span><br><span class="line">                    &quot;select#&quot;: <span class="number">2</span>,</span><br><span class="line">                    &quot;from&quot;: &quot;IN (SELECT)&quot;,</span><br><span class="line">                    &quot;to&quot;: &quot;EXISTS (CORRELATED SELECT)&quot;,</span><br><span class="line">                    &quot;chosen&quot;: <span class="literal">true</span>,</span><br><span class="line">                    &quot;evaluating_constant_having_conditions&quot;: [</span><br><span class="line">                    ]</span><br><span class="line">                  &#125;</span><br><span class="line">...</span><br><span class="line"># 变化为：</span><br><span class="line"># <span class="comment">/* select#1 */</span> <span class="keyword">select</span> `t1`.`a` <span class="keyword">AS</span> `a`,`t1`.`b` <span class="keyword">AS</span> `b` <span class="keyword">from</span> `t1` <span class="keyword">where</span> <span class="operator">&lt;</span>in_optimizer<span class="operator">&gt;</span>(`t1`.`b`,<span class="operator">&lt;</span><span class="keyword">exists</span><span class="operator">&gt;</span>(<span class="comment">/* select#2 */</span> <span class="keyword">select</span> <span class="built_in">sum</span>(`t1`.`a`) <span class="keyword">from</span> `t1` <span class="keyword">having</span> (<span class="operator">&lt;</span>cache<span class="operator">&gt;</span>(`t1`.`b`) <span class="operator">=</span> <span class="operator">&lt;</span>ref_null_helper<span class="operator">&gt;</span>(<span class="built_in">sum</span>(`t1`.`a`)))))</span><br></pre></td></tr></table></figure>

<h3 id="3-1-6-转换的标量子查询转换成Derived-Table"><a href="#3-1-6-转换的标量子查询转换成Derived-Table" class="headerlink" title="3.1.6 转换的标量子查询转换成Derived Table"></a>3.1.6 转换的标量子查询转换成Derived Table</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> b, <span class="built_in">max</span>(a) <span class="keyword">AS</span> ma <span class="keyword">from</span> t1 <span class="keyword">group</span> <span class="keyword">by</span> b <span class="keyword">having</span> ma <span class="operator">&lt;</span> (<span class="keyword">select</span> <span class="built_in">max</span>(t2.a) <span class="keyword">from</span> t2 <span class="keyword">where</span> t2.b<span class="operator">=</span>t1.b);</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> information_schema.optimizer_trace\G</span><br><span class="line">...</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;derived&quot;: &#123;</span><br><span class="line">              &quot;table&quot;: &quot; `derived_1_2`&quot;,</span><br><span class="line">              &quot;select#&quot;: <span class="number">2</span>,</span><br><span class="line">              &quot;materialized&quot;: <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;transformation&quot;: &#123;</span><br><span class="line">              &quot;select#&quot;: <span class="number">2</span>,</span><br><span class="line">              &quot;from&quot;: &quot;scalar subquery&quot;,</span><br><span class="line">              &quot;to&quot;: &quot;derived table&quot;,</span><br><span class="line">              &quot;expanded_query&quot;: &quot;/* select#1 */ select `t1`.`b` AS `b`,max(`t1`.`a`) AS `ma` from (`t1` left join (/* select#2 */ select max(`t2`.`a`) AS `max(t2.a)`,`t2`.`b` AS `b` from `t2` group by `t2`.`b`) `derived_1_2` on((`derived_1_2`.`b` = `t1`.`b`))) group by `t1`.`b` having (`ma` &lt; `derived_1_2`.`max(t2.a)`)&quot;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h3 id="3-1-7-SEMI-JOIN转换为NESTED-JOIN"><a href="#3-1-7-SEMI-JOIN转换为NESTED-JOIN" class="headerlink" title="3.1.7 SEMI-JOIN转换为NESTED-JOIN"></a>3.1.7 SEMI-JOIN转换为NESTED-JOIN</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">inner</span> <span class="keyword">join</span> t2 <span class="keyword">on</span> t1.b<span class="operator">=</span>t2.b;</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> information_schema.optimizer_trace\G</span><br><span class="line">...</span><br><span class="line">            &quot;transformations_to_nested_joins&quot;: &#123;</span><br><span class="line">              &quot;transformations&quot;: [</span><br><span class="line">                &quot;JOIN_condition_to_WHERE&quot;,</span><br><span class="line">                &quot;parenthesis_removal&quot;</span><br><span class="line">              ],</span><br><span class="line">              &quot;expanded_query&quot;: &quot;/* select#1 */ select `t1`.`a` AS `a`,`t1`.`b` AS `b`,`t2`.`a` AS `a`,`t2`.`b` AS `b` from `t1` join `t2` where (`t1`.`b` = `t2`.`b`)&quot;</span><br><span class="line">            &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>注意：LEFT JOIN 不能把JOIN优化为WHERE：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">left</span> <span class="keyword">join</span> t2 <span class="keyword">on</span> t1.b<span class="operator">=</span>t2.b;</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> information_schema.optimizer_trace\G</span><br><span class="line">...</span><br><span class="line">            &quot;transformations_to_nested_joins&quot;: &#123;</span><br><span class="line">              &quot;transformations&quot;: [</span><br><span class="line">                &quot;parenthesis_removal&quot;</span><br><span class="line">              ],</span><br><span class="line">              &quot;expanded_query&quot;: &quot;/* select#1 */ select `t1`.`a` AS `a`,`t1`.`b` AS `b`,`t2`.`a` AS `a`,`t2`.`b` AS `b` from `t1` left join `t2` on((`t1`.`b` = `t2`.`b`))&quot;</span><br><span class="line">            &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>但是LEFT JOIN右表加条件可以优化为JOIN：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">left</span> <span class="keyword">join</span> t2 <span class="keyword">on</span> t1.b <span class="operator">=</span> t2.b <span class="keyword">where</span> t2.a<span class="operator">=</span><span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> information_schema.optimizer_trace\G</span><br><span class="line">...</span><br><span class="line">            &quot;transformations_to_nested_joins&quot;: &#123;</span><br><span class="line">              &quot;transformations&quot;: [</span><br><span class="line">                &quot;outer_join_to_inner_join&quot;,</span><br><span class="line">                &quot;JOIN_condition_to_WHERE&quot;,</span><br><span class="line">                &quot;parenthesis_removal&quot;</span><br><span class="line">              ],</span><br><span class="line">              &quot;expanded_query&quot;: &quot;/* select#1 */ select `t1`.`a` AS `a`,`t1`.`b` AS `b`,`t2`.`a` AS `a`,`t2`.`b` AS `b` from `t1` join `t2` where ((`t2`.`a` = 5) and (`t1`.`b` = `t2`.`b`))&quot;</span><br><span class="line">            &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h2 id="3-2-join-optimization"><a href="#3-2-join-optimization" class="headerlink" title="3.2 join_optimization"></a>3.2 join_optimization</h2><p>该阶段会做一些prepare后续的逻辑转换，主要有优化器基于cost的优化过程，包括访问方式、连接方法和顺序，以及一些针对执行计划的特定优化。会解决一些遗留的一些逻辑转换规则，如NOT消除、等值传递、常量计算和条件移除。</p>
<p>join_optimization主要包括：</p>
<ul>
<li>condition_processing：WHERE&#x2F;ON&#x2F;HAVING 条件中的基本重写（basic rewrite）</li>
<li>substitute_generated_columns：构造进行 ref 和 eq_ref 访问的可能方法</li>
<li>table_dependencies：表的依赖信息</li>
<li>ref_optimizer_key_uses：查看SQL中每个表可以使用的ref索引，用于后续计算访问和连接代价</li>
<li>pulled_out_semijoin_tables：把semi-join优化为inner-join</li>
<li>rows_estimation：估算表行数和扫描的代价。如果查询中存在range扫描的话，对range扫描进行计划分析及代价估算</li>
<li>execution_plan_for_potential_materialization：计算子查询优化策略的花费，选择最优</li>
<li>considered_execution_plans：对比各可行计划的代价，选择相对最优的执行计划</li>
<li>attaching_conditions_to_tables：一旦join的连接顺序确定，添加附加条件，使得条件尽可能筛选单表数据</li>
<li>optimizing_distinct_group_by_order_by：于优化DISTINCT，GROUP BY、ORDER BY子句，例如将 distinct 转换为 group by，消除不必要的 trivial order by</li>
<li>reconsidering_access_paths_for_index_ordering：最终对排序再进行一次索引选择优化</li>
<li>finalizing_table_conditions：进行最后一轮的 condition 优化，这一步主要是去除冗余的 filter，将缓存表达式中的常量，避免每一行数据都重新计算等，得到最终的、经过优化后的表条件</li>
<li>refine_plan：优化后的执行计划</li>
<li>considering_tmp_tables：为执行计划中各个 SQL 算子按需分配 tmp table</li>
</ul>
<p>MySQL中基于成本的优化主要在optimize阶段，在单表查询时会主要关注optimize阶段的rows_estimation过程（预估不同单表访问方法的访问成本）这个过程，这个过程深入分析了对单表查询的各种执行方案的成本。在多表连接查询的时候，需要更多关注considered_execution_plans过程（分析各种可能的执行计划及成本）这个过程，这个过程里会写明各种不同的连接方式所对应的成本。</p>
<p>优化器最终会选择成本最低的那种方案来作为最终的执行计划，也就是使用 explain 语句所展现出的那种方案。</p>
<h3 id="3-2-1表访问方式"><a href="#3-2-1表访问方式" class="headerlink" title="3.2.1表访问方式"></a>3.2.1表访问方式</h3><p>表访问方式主要分为 Table Scan（全表扫描）、Index Look Up （ref访问）方式、Index Scan（索引扫描），Range Index Scan（索引范围查询）和一些替代的 Quick Range Scan（快速范围访问方式）。每一种分类是可以独立计算选出最佳方案，最终在所有类型的最佳方案中选择代价最低的访问方式。除了 Table Scan 是全表扫描方式之外，其余都属于索引扫描，只是根据索引的定义情况和利用索引的执行方式不同，区分了多种类型而已。 </p>
<p>通常优化器使用索引的原则如下：</p>
<ul>
<li>索引列作为过滤条件出现在 WHERE、HAVING、ON 子句中，这样有利于利用索引过滤元组</li>
<li>索引列是被连接的表（内表）对象的列且存在于连接条件中，连接条件会出现在 WHERE、ON、USING 子句中</li>
<li>索引列出现在 AGGRE 子句中，例如在索引列上求 MIN、MAX 值等</li>
<li>索引列出现在 GROUP BY 、ORDER BY 、DISTINCT，可以利用有序索引避免排序操作</li>
</ul>
<p>访问类型，是较为重要的一个指标，结果值从好到坏依次是：</p>
<p>system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL </p>
<p>一般来说，得保证查询至少达到range级别，最好能达到ref。</p>
<ul>
<li>system：表仅有一行（&#x3D;系统表）。</li>
<li>const：表中最多一个匹配行，它将在查询开始前先被读取。因为仅有一行，在这行的列值可被优化器的剩余部分认为是常数。const 类型用于用常数值比较 primary key 或 unique 索引的所有部分时。</li>
<li>eq_ref：对于每个来自于前面的表的行组合，从该表中读取一行。这可能是除了 const 类型外最好的连接类型。它用在一个索引的所有部分被连接使用并且索引是 UNIQUE 或 PRIMARY KEY 时。eq_ref 可以用于使用 &#x3D; 操作符比较的带索引的列。比较值可以为常量或一个使用在该表前面所读取的表的列的表达式。</li>
<li>ref：对于每个来自于前面的表的行组合，所有匹配索引值的行将从这张表中读取。同时需要满足连接只使用键的最左前缀，且键不是 UNIQUE 或 PRIMARY KEY（换句话说，如果连接不能基于关键字选择单个行的话），则使用 ref。如果使用的键仅仅匹配少量行，该连接类型是不错的。ref 可以用于使用 &#x3D; 或 &lt;&#x3D;&gt; 操作符的带索引的列。</li>
<li>ref_or_null：该联接类型如同 ref，但是添加 了MySQL 可以专门搜索包含 NULL 值的行。在解决子查询中经常使用该连接类型的优化。</li>
<li>index_merge：该连接类型表示使用了索引合并优化方法。在这种情况下，key 列包含了使用的索引的清单，key_len 包含了使用的索引的最长的关键元素。</li>
<li>unique_subquery：该类型替换了下面形式的 IN 子查询的 ref：value IN (SELECT primary_key FROM single_table WHERE some_expr); unique_subquery 是一个索引查找函数，可以完全替换子查询，效率更高。</li>
<li>index_subquery：该类型类似于 unique_subquery。可以替换 IN 子查询，但只适合下列形式的子查询中的非唯一索引：value IN SELECT key_column FROM single_table WHERE some_expr</li>
<li>range：只检索给定范围的行，使用一个索引来选择行。key 列显示使用了哪个索引。key_len 包含所使用索引的最长关键元素。在该类型中 ref 列为 NULL。当使用&#x3D;、&lt;&gt;、&gt;、&gt;&#x3D;、&lt;、&lt;&#x3D;、IS NULL、&lt;&#x3D;&gt;、BETWEEN 或者 IN 操作符，用常量比较关键字列时，可以使用 range</li>
<li>index：该联接类型与 ALL 相同，除了只有索引树被扫描。这通常比 ALL 快，因为索引文件通常比数据文件小。</li>
<li>all：对于每个来自于先前的表的行组合，进行完整的表扫描。如果表是第一个没被标记为 const 的表，这通常性能很差。通常可以增加更多的索引而不要使用 ALL，使得行能基于前面的表中的常数值或列值被检索出。</li>
</ul>
<p>接下来，从join_optimization各个part入手，分析这一过程。</p>
<h3 id="3-2-2-condition-processing"><a href="#3-2-2-condition-processing" class="headerlink" title="3.2.2 condition_processing"></a>3.2.2 condition_processing</h3><p>condition_processing对应sql&#x2F;sql_optimizer.cc的optimize_cond函数，主要优化查询的 where 和 having 条件（on也是一种where），主要完成以下优化：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">condition_processing&#123; ：条件句处理。</span><br><span class="line">    transformation&#123;：转换类型句。这三次的转换分别是</span><br><span class="line">        equality_propagation（等值条件句转换），如：a = b and b = c and c = 5，推导出a = b = c = 5</span><br><span class="line">        constant_propagation（常量条件句转换），如：根据 x=42 推导出所有多元等式 (x, y, z, …) 中的字段都等于 42</span><br><span class="line">        trivial_condition_removal（无效条件移除的转换），消除那些始终为true或者为false的条件，如：1 = 1</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>example：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> a <span class="keyword">from</span> t1 <span class="keyword">where</span> a<span class="operator">=</span>b <span class="keyword">and</span> b<span class="operator">=</span>c <span class="keyword">group</span> <span class="keyword">by</span> a,b <span class="keyword">having</span> a<span class="operator">=</span>b <span class="keyword">and</span> b<span class="operator">=</span><span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> information_schema.optimizer_trace\G</span><br><span class="line">...</span><br><span class="line">            &quot;condition_processing&quot;: &#123;</span><br><span class="line">              &quot;condition&quot;: &quot;WHERE&quot;,</span><br><span class="line">              &quot;original_condition&quot;: &quot;((`t1`.`a` = `t1`.`b`) and (`t1`.`b` = `t1`.`c`))&quot;,</span><br><span class="line">              &quot;steps&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                  &quot;transformation&quot;: &quot;equality_propagation&quot;,</span><br><span class="line">                  &quot;resulting_condition&quot;: &quot;(multiple equal(`t1`.`a`, `t1`.`b`, `t1`.`c`))&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                  &quot;transformation&quot;: &quot;constant_propagation&quot;,</span><br><span class="line">                  &quot;resulting_condition&quot;: &quot;(multiple equal(`t1`.`a`, `t1`.`b`, `t1`.`c`))&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                  &quot;transformation&quot;: &quot;trivial_condition_removal&quot;,</span><br><span class="line">                  &quot;resulting_condition&quot;: &quot;multiple equal(`t1`.`a`, `t1`.`b`, `t1`.`c`)&quot;</span><br><span class="line">                &#125;</span><br><span class="line">              ]</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;condition_processing&quot;: &#123;</span><br><span class="line">              &quot;condition&quot;: &quot;HAVING&quot;,</span><br><span class="line">              &quot;original_condition&quot;: &quot;((`t1`.`a` = `t1`.`b`) and (`t1`.`b` = 5))&quot;,</span><br><span class="line">              &quot;steps&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                  &quot;transformation&quot;: &quot;constant_propagation&quot;,</span><br><span class="line">                  &quot;resulting_condition&quot;: &quot;((`t1`.`a` = 5) and (`t1`.`b` = 5))&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                  &quot;transformation&quot;: &quot;trivial_condition_removal&quot;,</span><br><span class="line">                  &quot;resulting_condition&quot;: &quot;((`t1`.`a` = 5) and (`t1`.`b` = 5))&quot;</span><br><span class="line">                &#125;</span><br><span class="line">              ]</span><br><span class="line">            &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h3 id="3-2-3-substitute-generated-columns"><a href="#3-2-3-substitute-generated-columns" class="headerlink" title="3.2.3 substitute_generated_columns"></a>3.2.3 substitute_generated_columns</h3><p>substitute_generated_columns对应sql&#x2F;optimizer.cc的substitute_gc函数，主要检查 query 的 where 条件、order by 、order by等，将其中的表达式替换为匹配的 generated column，进而可以让优化器来选择functional index。</p>
<blockquote>
<p>MySQL从8.0.13开始支持functional index。Functional index类似于ORACLE的Function-Based Indexes。该索引可以根据将索引定义的表达式的值按照索引顺序存到索引里，进而减少表达式的计算，加速查询。</p>
</blockquote>
<p>example：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">alter</span> <span class="keyword">table</span> t1 <span class="keyword">add</span> index fun_abs((<span class="built_in">abs</span>(a)));</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> a <span class="keyword">from</span> t1 <span class="keyword">where</span> <span class="built_in">abs</span>(a)<span class="operator">=</span><span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> information_schema.optimizer_trace\G</span><br><span class="line">...</span><br><span class="line">            &quot;substitute_generated_columns&quot;: &#123;</span><br><span class="line">              &quot;resulting_condition&quot;: &quot;(abs(`a`) = 5)&quot;</span><br><span class="line">            &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>详见：<a target="_blank" rel="noopener" href="http://mysql.taobao.org/monthly/2019/02/06/">MySQL · 源码分析 · 8.0 Functional index的实现过程</a></p>
<h3 id="3-2-4-table-dependencies"><a href="#3-2-4-table-dependencies" class="headerlink" title="3.2.4 table_dependencies"></a>3.2.4 table_dependencies</h3><p>table_dependencies对应sql&#x2F;sql_optimizer.cc的trace_table_dependencies函数，负责分析表之间的依赖关系。主要有：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;table_dependencies&quot;: &#123;</span><br><span class="line">    &quot;table&quot;: 涉及的表名，如果有别名，也会展示出来</span><br><span class="line">    &quot;row_may_be_null&quot;: 行是否可能为NULL，指JOIN操作之后，这张表里的数据是不是可能为NULL。如果语句中使用了LEFT JOIN，则后一张表的该参数会显示为true</span><br><span class="line">    &quot;map_bit&quot;: 表的映射编号，从0开始递增</span><br><span class="line">    &quot;depends_on_map_bits&quot;: 依赖的映射表。主要是当使用STRAIGHT_JOIN强行控制连接顺序或者LEFT JOIN/RIGHT JOIN有顺序差别时，会在该参数展示前置表的map_bit值</span><br></pre></td></tr></table></figure>

<p>example：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 straight_join t2 <span class="keyword">on</span> t1.a<span class="operator">=</span>t2.a;</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> information_schema.optimizer_trace\G</span><br><span class="line">...</span><br><span class="line">            &quot;table_dependencies&quot;: [</span><br><span class="line">              &#123;</span><br><span class="line">                &quot;table&quot;: &quot;`t1`&quot;,</span><br><span class="line">                &quot;row_may_be_null&quot;: <span class="literal">false</span>,</span><br><span class="line">                &quot;map_bit&quot;: <span class="number">0</span>,</span><br><span class="line">                &quot;depends_on_map_bits&quot;: [</span><br><span class="line">                ]</span><br><span class="line">              &#125;,</span><br><span class="line">              &#123;</span><br><span class="line">                &quot;table&quot;: &quot;`t2`&quot;,</span><br><span class="line">                &quot;row_may_be_null&quot;: <span class="literal">false</span>,</span><br><span class="line">                &quot;map_bit&quot;: <span class="number">1</span>,</span><br><span class="line">                &quot;depends_on_map_bits&quot;: [</span><br><span class="line">                  <span class="number">0</span></span><br><span class="line">                ]</span><br><span class="line">              &#125;</span><br><span class="line">            ]</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h3 id="3-2-5-ref-optimizer-key-uses"><a href="#3-2-5-ref-optimizer-key-uses" class="headerlink" title="3.2.5 ref_optimizer_key_uses"></a>3.2.5 ref_optimizer_key_uses</h3><p>ref_optimizer_key_uses对应sql&#x2F;sql_optimizer.cc的update_ref_and_keys函数，查看SQL中每个表可以使用的ref索引，用于后续计算访问和连接代价。如果使用了组合索引的多个部分（例如本例，用到了index(from_date, to_date) 的多列索引），则会在ref_optimizer_key_uses下列出多个元素，每个元素中会列出ref使用的索引及对应值。</p>
<p>ref是必须为等值比较的方式，通常在单表条件和多表连接的条件中。</p>
<p>example：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> a <span class="keyword">from</span> t1 <span class="keyword">where</span> <span class="built_in">abs</span>(a)<span class="operator">=</span><span class="number">5</span>; # KEY `fun_abs` ((<span class="built_in">abs</span>(`a`)))</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> information_schema.optimizer_trace\G</span><br><span class="line">...</span><br><span class="line">            &quot;ref_optimizer_key_uses&quot;: [</span><br><span class="line">              &#123;</span><br><span class="line">                &quot;table&quot;: &quot;`t1`&quot;,</span><br><span class="line">                &quot;field&quot;: &quot;abs(`a`)&quot;,</span><br><span class="line">                &quot;equals&quot;: &quot;5&quot;,</span><br><span class="line">                &quot;null_rejecting&quot;: <span class="literal">true</span></span><br><span class="line">              &#125;</span><br><span class="line">            ]</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>ref是必须为等值比较的方式，如果条件是大于或者小于，这里就不会显示。</p>
<h3 id="3-2-6-pulled-out-semijoin-tables"><a href="#3-2-6-pulled-out-semijoin-tables" class="headerlink" title="3.2.6 pulled_out_semijoin_tables"></a>3.2.6 pulled_out_semijoin_tables</h3><p>pulled_out_semijoin_tables对应sql&#x2F;sql_optimizer.cc的pull_out_semijoin_tables函数，用于把semi-join优化为inner-join。优化的条件，是子查询的目标列，使用了主键或唯一键。</p>
<p>该函数检查semi-join nest中的function dependency(例如EQ_REF(outer_table))，对于这种table，从semi-join nest中抽取出来，放到外层join nest-&gt;join_list中。</p>
<p>对于EQ_REF，是保证能join到，且只能join到一条的，所以对于存在性语义（where exist）来说，这个inner table表是没有用的，抽取出来后，semi-join nest的相关字段都要调整，sj-nest将可能被标记为correlated（内层条件变为了相关条件）</p>
<p>这个试了好久里面都是空的……以后有机会看到再补充吧</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">where</span> t1.a <span class="keyword">in</span> (<span class="keyword">select</span> t2.a <span class="keyword">from</span> t2); # KEY `primary_key` (`a`)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> information_schema.optimizer_trace\G</span><br><span class="line">...</span><br><span class="line">            &quot;pulled_out_semijoin_tables&quot;: [</span><br><span class="line">            ]</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h3 id="3-2-7-rows-estimation"><a href="#3-2-7-rows-estimation" class="headerlink" title="3.2.7 rows_estimation"></a>3.2.7 rows_estimation</h3><p>rows_estimation对应sql&#x2F;sql_optimizer.cc的JOIN::estimate_rowcount函数，用于估算需要扫描的记录数，并在后续的优化过程中持续计算每个候选执行计划的 cost。</p>
<p>优化器的成本模型也由server和engine两层来组成，包含查询执行期间发生的操作的成本估计信息。Server层进行连接管理、权限链接，查询缓存（8.0已废弃）、语法解析、查询优化ICP等操作。在存储引擎层执行具体的数据存取操作。</p>
<ul>
<li>server_cost:一般服务层操作的优化器成本估算<ul>
<li>disk_temptable_create_cost： 代表了基于磁盘的存储引擎（InnoDB 和MyISAM）中创建临时表的成本估算</li>
<li>disk_temptable_row_cost： 代表了基于磁盘的存储引擎（InnoDB 和MyISAM）中写入或读取一条记录的成本</li>
<li>key_compare_cost：比较记录键的开销</li>
<li>memory_temptable_create_cost：在 MEMORY 存储引擎中创建内部临时表的评估成本</li>
<li>memory_temptable_row_cost：在 MEMORY 存储引擎中读取或写入内部临时表一条记录的评估成本</li>
<li>row_evaluate_cost：检测一条记录是否符合搜索条件的成本</li>
</ul>
</li>
<li>engine_cost:用于存储引擎的操作的优化器成本估算<ul>
<li>io_block_read_cost：从磁盘读取索引或数据块的开销</li>
<li>memory_block_read_cost：类似于io_block_read_cost，但表示从内存中的数据库缓冲区读取索引或数据块的开销</li>
</ul>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span>  <span class="operator">*</span> <span class="keyword">FROM</span> mysql.server_cost;</span><br><span class="line"><span class="operator">+</span><span class="comment">------------------------------+------------+---------------------+---------+---------------+</span></span><br><span class="line"><span class="operator">|</span> cost_name                    <span class="operator">|</span> cost_value <span class="operator">|</span> last_update         <span class="operator">|</span> comment <span class="operator">|</span> default_value <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------------------+------------+---------------------+---------+---------------+</span></span><br><span class="line"><span class="operator">|</span> disk_temptable_create_cost   <span class="operator">|</span>       <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">2024</span><span class="number">-02</span><span class="number">-04</span> <span class="number">11</span>:<span class="number">15</span>:<span class="number">41</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>            <span class="number">20</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> disk_temptable_row_cost      <span class="operator">|</span>       <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">2024</span><span class="number">-02</span><span class="number">-04</span> <span class="number">11</span>:<span class="number">15</span>:<span class="number">41</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>           <span class="number">0.5</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> key_compare_cost             <span class="operator">|</span>       <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">2024</span><span class="number">-02</span><span class="number">-04</span> <span class="number">11</span>:<span class="number">15</span>:<span class="number">41</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>          <span class="number">0.05</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> memory_temptable_create_cost <span class="operator">|</span>       <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">2024</span><span class="number">-02</span><span class="number">-04</span> <span class="number">11</span>:<span class="number">15</span>:<span class="number">41</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>             <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> memory_temptable_row_cost    <span class="operator">|</span>       <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">2024</span><span class="number">-02</span><span class="number">-04</span> <span class="number">11</span>:<span class="number">15</span>:<span class="number">41</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>           <span class="number">0.1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> row_evaluate_cost            <span class="operator">|</span>       <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">2024</span><span class="number">-02</span><span class="number">-04</span> <span class="number">11</span>:<span class="number">15</span>:<span class="number">41</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>           <span class="number">0.1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------------------+------------+---------------------+---------+---------------+</span></span><br><span class="line"><span class="number">6</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span>  <span class="operator">*</span> <span class="keyword">FROM</span> mysql.engine_cost;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+-------------+------------------------+------------+---------------------+---------+---------------+</span></span><br><span class="line"><span class="operator">|</span> engine_name <span class="operator">|</span> device_type <span class="operator">|</span> cost_name              <span class="operator">|</span> cost_value <span class="operator">|</span> last_update         <span class="operator">|</span> comment <span class="operator">|</span> default_value <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+-------------+------------------------+------------+---------------------+---------+---------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">default</span>     <span class="operator">|</span>           <span class="number">0</span> <span class="operator">|</span> io_block_read_cost     <span class="operator">|</span>       <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">2024</span><span class="number">-02</span><span class="number">-04</span> <span class="number">11</span>:<span class="number">15</span>:<span class="number">41</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>             <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">default</span>     <span class="operator">|</span>           <span class="number">0</span> <span class="operator">|</span> memory_block_read_cost <span class="operator">|</span>       <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">2024</span><span class="number">-02</span><span class="number">-04</span> <span class="number">11</span>:<span class="number">15</span>:<span class="number">41</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>          <span class="number">0.25</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+-------------+------------------------+------------+---------------------+---------+---------------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<p>Server层主要是CPU代价，Engine层主要是IO代价，代价模型将操作分为两类io_cost和cpu_cost，io_cost+cpu_cost就是总的cost。</p>
<p>基于以上成本值，分析rows_estimation部分。</p>
<p>rows_estimation主要由以下部分组成：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">rows_estimation&#123; ：估算表行数和扫描的代价。如果查询中存在range扫描的话，对range扫描进行计划分析及代价估算。</span><br><span class="line">  table_scan：全表扫描的行数(rows)以及所需要的代价(cost)</span><br><span class="line">  potential_range_indexes：该阶段会列出表中所有的索引并分析其是否可用，并且还会列出索引中可用的列字段</span><br><span class="line">  best_covering_index_scan：如果有覆盖索引，列出覆盖索引情况</span><br><span class="line">  setup_range_conditions：如果有可下推的条件，则带条件考虑范围查询</span><br><span class="line">  group_index_range：当使用了GROUP BY或DISTINCT时，是否有合适的索引可用</span><br><span class="line">                     当未使用GROUP BY或DISTINCT时，会显示chosen=false, cause=not_group_by_or_distinct；</span><br><span class="line">                    如使用了GROUP BY或DISTINCT，但是多表查询时，会显示chosen=false，cause =not_single_table。</span><br><span class="line">                    其他情况下会尝试分析可用的索引（potential_group_range_indexes）并计算对应的扫描行数及其所需代价</span><br><span class="line">  skip_scan_range：是否使用了skip_scan_range</span><br><span class="line">  analyzing_range_alternatives ：分析可选方案的代价。</span><br><span class="line">  chosen_range_access_summary：</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>省略不涉及的部分，针对各个小模块展开说明。</p>
<p><strong>table_scan:</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;table&quot;: &quot;`t2`&quot;,</span><br><span class="line">&quot;range_analysis&quot;: &#123;</span><br><span class="line">  &quot;table_scan&quot;: &#123;     # 全表扫描的代价评估</span><br><span class="line">    &quot;rows&quot;: 5,        # 全表扫描的行数</span><br><span class="line">    &quot;cost&quot;: 2.85      # 全表扫描的代价，等于io_cost(页数) + 1.1 + cpu_cost(行数) + 1.0，即 0.25 + 1.1 + 0.1*5 + 1 = 2.85</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>

<p>详细的cost计算及分析：</p>
<p><code>io_cost = clustered_index_size (统计信息中的主键页数) * avg_single_page_cost(读取一个页的平均成本)</code></p>
<p>其中：</p>
<p><code>avg_single_page_cost = pages_in_memory_percent * memory_block_read_cost + pages_on_disk_percent * io_block_read_cost</code></p>
<p>pages_in_memory_percent  为已经加载到 Buffer Pool 中的叶结点占所有叶结点的比例</p>
<p>pages_on_disk_percent 为没有加载到 Buffer Pool 中的叶结点占所有叶结点的比例</p>
<p>所以当数据已经全部读取到buffer pool中的时候：</p>
<p><code>io_cost=clustered_index_size * memory_block_read_cost</code></p>
<p>都没有读取到buffer pool中的时候：</p>
<p><code>io_cost=clustered_index_size * io_block_read_cost</code></p>
<p>当部分数据在buffer pool中，部分数据需要从磁盘读取时，这时的系数介于0.25到1之间。</p>
<p><code>cpu_cost = n_rows(统计信息中记录数) * row_evaluate_cost</code></p>
<p><strong>potential_range_indexes:</strong></p>
<p>首先先列出该表可以使用RANGE扫描的key索引列表，并且还会列出索引中可用的列字段。</p>
<p>这里直接会判定是否所以可以被考虑，”usable”代表是否可能被用到，”cause”代表被拒绝的原因。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&quot;table&quot;: &quot;`t2`&quot;,</span><br><span class="line">&quot;range_analysis&quot;: &#123;</span><br><span class="line">...</span><br><span class="line">&quot;potential_range_indexes&quot;: [</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;index&quot;: &quot;ka&quot;,</span><br><span class="line">    &quot;usable&quot;: <span class="literal">false</span>,</span><br><span class="line">    &quot;cause&quot;: &quot;not_applicable&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;index&quot;: &quot;kb&quot;,</span><br><span class="line">    &quot;usable&quot;: <span class="literal">true</span>,</span><br><span class="line">    &quot;key_parts&quot;: [</span><br><span class="line">      &quot;b&quot;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>

<p><strong>best_covering_index_scan:</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&quot;table&quot;: &quot;`t5`&quot;,</span><br><span class="line">&quot;range_analysis&quot;: &#123;</span><br><span class="line">...</span><br><span class="line">  &quot;best_covering_index_scan&quot;: &#123;</span><br><span class="line">    &quot;index&quot;: &quot;kb&quot;,</span><br><span class="line">    &quot;cost&quot;: 0.550549,</span><br><span class="line">    &quot;chosen&quot;: true</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>

<p>当然，即使有覆盖索引，也可能出现由于过滤性不强导致全表扫描方式代价比覆盖索引代价低，而选择全表扫描的情况。</p>
<p>走索引的成本的计算方法和全表扫描的计算方法类似，其中io_cost与搜索的区间数有关，在无需回表的情况下，计算方式为：</p>
<p><code>io_cost = (要读取的索引页的数量) * avg_single_page_cost</code></p>
<p><code>cpu_cost = (记录数) * row_evaluate_cost</code></p>
<blockquote>
<p>avg_single_page_cost &#x3D; pages_in_memory_percent * memory_block_read_cost + pages_on_disk_percent * io_block_read_cost</p>
<p>pages_in_memory_percent  为已经加载到 Buffer Pool 中的叶结点占所有叶结点的比例</p>
<p>pages_on_disk_percent 为没有加载到 Buffer Pool 中的叶结点占所有叶结点的比例</p>
</blockquote>
<p><strong>setup_range_conditions:</strong></p>
<p>如果有可下推的条件，则带条件考虑范围查询：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&quot;table&quot;: &quot;`t6`&quot;,</span><br><span class="line">&quot;range_analysis&quot;: &#123;</span><br><span class="line">...</span><br><span class="line">  &quot;setup_range_conditions&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;impossible_condition&quot;: &#123;</span><br><span class="line">        &quot;cause&quot;: &quot;value_out_of_range&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  &quot;impossible_range&quot;: <span class="literal">true</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>这里有一个bug report：Different results return when executing the same query with different plans </p>
<p><strong>group_index_range：</strong></p>
<p>接下来就开始查看是否有快速范围查找的方式（Quick Range Scan），如group_index_range和skip_scan_range等。</p>
<p>当使用了GROUP BY或DISTINCT时，是否有合适的索引可用。</p>
<p>当未使用GROUP BY或DISTINCT时，会显示chosen&#x3D;false, cause&#x3D;not_group_by_or_distinct，如果可以使用，也有可能因为cost原因没有选择。</p>
<p>如使用了GROUP BY或DISTINCT，但是多表查询时，会显示chosen&#x3D;false，cause &#x3D;not_single_table。</p>
<p>其他情况下会尝试分析可用的索引（potential_group_range_indexes）并计算对应的扫描行数及其所需代价。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"># 一个不能使用的例子</span><br><span class="line">&quot;table&quot;: &quot;`t4`&quot;,</span><br><span class="line">&quot;range_analysis&quot;: &#123;</span><br><span class="line">...</span><br><span class="line">  &quot;group_index_range&quot;: &#123;</span><br><span class="line">    &quot;potential_group_range_indexes&quot;: [</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;index&quot;: &quot;PRIMARY&quot;,</span><br><span class="line">        &quot;usable&quot;: <span class="literal">false</span>,</span><br><span class="line">        &quot;cause&quot;: &quot;not_covering&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"># 一个可以使用的例子</span><br><span class="line">&quot;table&quot;: &quot;`t3`&quot;,</span><br><span class="line">&quot;range_analysis&quot;: &#123;</span><br><span class="line">...</span><br><span class="line">  &quot;group_index_range&quot;: &#123;</span><br><span class="line">    &quot;potential_group_range_indexes&quot;: [</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;index&quot;: &quot;PRIMARY&quot;,</span><br><span class="line">        &quot;covering&quot;: <span class="literal">true</span>,</span><br><span class="line">        &quot;rows&quot;: <span class="number">6</span>,</span><br><span class="line">        &quot;cost&quot;: <span class="number">1.15</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>如果存在满足的index，还有可能输出best_group_range_summary，如下。</p>
<p><strong>best_group_range_summary：</strong></p>
<p>对于group_index_range步骤中判断的多个满足的index，评估哪个应该被放弃：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&quot;table&quot;: &quot;`t4`&quot;,</span><br><span class="line">&quot;range_analysis&quot;: &#123;</span><br><span class="line">...</span><br><span class="line">  &quot;best_group_range_summary&quot;: &#123;</span><br><span class="line">    &quot;type&quot;: &quot;index_group&quot;,</span><br><span class="line">    &quot;index&quot;: &quot;ka&quot;,</span><br><span class="line">    &quot;group_attribute&quot;: <span class="keyword">null</span>,</span><br><span class="line">    &quot;min_aggregate&quot;: <span class="literal">false</span>,</span><br><span class="line">    &quot;max_aggregate&quot;: <span class="literal">false</span>,</span><br><span class="line">    &quot;distinct_aggregate&quot;: <span class="literal">false</span>,</span><br><span class="line">    &quot;rows&quot;: <span class="number">6</span>,</span><br><span class="line">    &quot;cost&quot;: <span class="number">1.15</span>,</span><br><span class="line">    &quot;key_parts_used_for_access&quot;: [</span><br><span class="line">      &quot;a&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;ranges&quot;: [</span><br><span class="line">    ],</span><br><span class="line">    &quot;chosen&quot;: <span class="literal">false</span>,</span><br><span class="line">    &quot;cause&quot;: &quot;cost&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><strong>skip_scan_range:</strong></p>
<p>是否使用了skip scan。</p>
<p>在之前的版本中，如果要使用到索引进行扫描，条件必须满足索引前缀列，比如索引idx(col1,col2), 如果where条件只包含col2的话，是无法有效的使用idx的, 它需要扫描索引上所有的行，然后再根据col2上的条件过滤。</p>
<p>MySQL从8.0.13版本开始支持一种新的range scan方式，称为Loose Skip Scan。该优化可以避免全量索引扫描，而是根据每个col1上的值+col2上的条件，启动多次range scan。每次range scan根据构建的key值直接在索引上定位，直接忽略了那些不满足条件的记录。</p>
<p>skip scan range的使用需要保证：</p>
<ul>
<li>表具有至少一个复合索引([A_1, …, A_k,] B_1, …, B_m, C [, D_1, …, D_n]，A、D可以为空)</li>
<li>该查询仅引用一张表</li>
<li>该查询不使用 GROUP BY 或 DISTINCT</li>
<li>该查询仅引用索引中的列</li>
<li>A_1, …, A_k 上的谓词必须是相等谓词并且它们必须是常量，（包括IN操作）</li>
<li>查询必须是联合查询，也就是说条件必须是：(cond1(key_part1) OR cond2(key_part1)) AND (cond1(key_part2) OR …) AND …</li>
<li>C上必须有一个范围条件</li>
<li>D 列上的条件是允许的。 D 上的条件必须与 C 上的范围条件结合起来。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;skip_scan_range&quot;: &#123;</span><br><span class="line">  &quot;type&quot;: &quot;skip_scan&quot;,</span><br><span class="line">  &quot;index&quot;: index_used_for_skip_scan,</span><br><span class="line">  &quot;key_parts_used_for_access&quot;: [key_parts_used_for_access],</span><br><span class="line">  &quot;range&quot;: [<span class="keyword">range</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和group_index_range一样，这里也会出现best_skip_scan_summary部分，在此不多分析。<br>参考：<a target="_blank" rel="noopener" href="http://mysql.taobao.org/monthly/2019/05/06/">MySQL · 引擎特性 · Skip Scan Range</a></p>
<p><strong>analyzing_range_alternatives:</strong></p>
<p>这时候优化器已经根据cost选出了一个最佳的访问方式（Table Scan vs Quick Range Scan），接下来优化器会继续分析各个索引的使用成本，包括range_scan_alternatives（range扫描分析）、analyzing_roworder_intersect（index merge分析）两个阶段，分别针对不同的情况进行执行代价的分析，从中选择出更优的执行计划。</p>
<ul>
<li>range_scan_alternatives：单独查看范围索引（Index Range Scan）是否有最有的方案，这些可能的选择都放在range_scan_alternatives中，可以看到具体使用的索引、索引估算代价的来源（dive、statistics、histogram等）、是否使用一些特殊的优化模式（rowid_ordered、using_mrr、index_only），已经该索引内存占用的比例。</li>
<li>analyzing_roworder_intersect：是否使用合并索引，即基于多个索引共同方式，也就是通过row ids排序后进行交集和并集的访问方式（index(a) &#x3D; 10 and index(b) &#x3D; 10 -&gt; a &#x3D; 10 and b &#x3D; 10）</li>
</ul>
<p>“chosen”代表是否该快速访问方式被使用，”cause”是被拒绝的原因，通常都会看到是由于cost被剪枝掉。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&quot;analyzing_range_alternatives&quot;: &#123;</span><br><span class="line">  &quot;range_scan_alternatives&quot;: [               # 扫描分析</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;index&quot;: &quot;kb&quot;,                         # 索引名</span><br><span class="line">      &quot;ranges&quot;: [                            # 扫描的条件范围</span><br><span class="line">        &quot;0 &lt; b&quot;</span><br><span class="line">      ],</span><br><span class="line">      &quot;index_dives_for_eq_ranges&quot;: <span class="literal">true</span>,     # 是否使用了index dive，受eq_range_index_dive_limit参数影响</span><br><span class="line">      &quot;rowid_ordered&quot;: <span class="literal">false</span>,                # 该<span class="keyword">range</span>扫描的结果集是否根据<span class="keyword">primary</span> key进行排序</span><br><span class="line">      &quot;using_mrr&quot;: <span class="literal">false</span>,                    # 是否用到了MRR</span><br><span class="line">      &quot;index_only&quot;: <span class="literal">false</span>,                   # 是否使用了覆盖索引</span><br><span class="line">      &quot;in_memory&quot;: <span class="number">1</span>,                        # 是否在内存里，用来计算访问的数据page不在内存而在磁盘，由于IO访问造成的代价，<span class="number">1</span>指的是数据都在内存中</span><br><span class="line">      &quot;rows&quot;: <span class="number">5</span>,                             # 扫描的行数</span><br><span class="line">      &quot;cost&quot;: <span class="number">2.01</span>,                          # 索引的使用成本</span><br><span class="line">      &quot;chosen&quot;: <span class="literal">true</span>                         # 是否使用了该索引</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  &quot;analyzing_roworder_intersect&quot;: &#123;          # 是否使用了索引合并（index <span class="keyword">merge</span>），如果未使用，会在cause中展示原因；如果使用了索引合并，会在该部分展示索引合并的代价</span><br><span class="line">    &quot;usable&quot;: <span class="literal">false</span>,</span><br><span class="line">    &quot;cause&quot;: &quot;too_few_roworder_scans&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在之前的分析中，介绍了全表扫描和覆盖索引的成本，这里针对二级索引并且需要回表的情况，给出成本的计算公式：</p>
<blockquote>
<p>在无需回表的情况下，计算方式为：</p>
<p>io_cost &#x3D; (要读取的索引页的数量) * avg_single_page_cost</p>
<p>cpu_cost &#x3D; (记录数) * row_evaluate_cost</p>
</blockquote>
<p>每次回表，还需要再进行一次IO和一次判断：</p>
<p><code>io_cost = (记录数) * avg_single_page_cost</code></p>
<p><code>cpu_cost = (记录数) *  row_evaluate_cost</code></p>
<p>需要注意的是当索引需要回表扫描时，在rows_estimation阶段并不会计算这个值，在considered_execution_plans阶段会重新加上这部分成本。</p>
<p>综上，针对二级索引并且需要回表的场景，全部成本的计算公式为：</p>
<p><code>io_cost = (要读取的索引页的数量) * avg_single_page_cost + (记录数) * avg_single_page_cost</code></p>
<p><code>cpu_cost = (记录数) * row_evaluate_cost + (记录数) *  row_evaluate_cost</code></p>
<p><strong>chosen_range_access_summary：</strong></p>
<p>得出了一定的中间结果之后，在summary阶段汇总前一阶段的中间结果确认最后的方案。</p>
<p>如果整个range分析过程中，有被选中的range扫描方式被选中，可以看到chosen_range_access_summary属性，否则没有。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&quot;chosen_range_access_summary&quot;: &#123;</span><br><span class="line">  &quot;range_access_plan&quot;: &#123;            # <span class="keyword">range</span>扫描最终选择的执行计划</span><br><span class="line">    &quot;type&quot;: &quot;range_scan&quot;,           # 展示执行计划的type，如果使用了索引合并，则会显示index_roworder_intersect</span><br><span class="line">    &quot;index&quot;: &quot;kb&quot;,                  # 索引名</span><br><span class="line">    &quot;rows&quot;: <span class="number">5</span>,                      # 扫描的行数</span><br><span class="line">    &quot;ranges&quot;: [                     # <span class="keyword">range</span>扫描的条件范围</span><br><span class="line">      &quot;0 &lt; b&quot;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;rows_for_plan&quot;: <span class="number">5</span>,               # 该执行计划的扫描行数</span><br><span class="line">  &quot;cost_for_plan&quot;: <span class="number">2.01</span>,            # 该执行计划的执行代价</span><br><span class="line">  &quot;chosen&quot;: <span class="literal">true</span>                    # 是否选择该执行计划</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-8-execution-plan-for-potential-materialization"><a href="#3-2-8-execution-plan-for-potential-materialization" class="headerlink" title="3.2.8 execution_plan_for_potential_materialization"></a>3.2.8 execution_plan_for_potential_materialization</h3><p>execution_plan_for_potential_materialization有两个对应的函数，一是sql&#x2F;sql_optimizer.cc的optimize_semijoin_nests_for_materialization，二是sql&#x2F;sql_optimizer.cc的compare_costs_of_subquery_strategies。</p>
<p>对于子查询，优化器有三种优化策略，分别是：</p>
<ul>
<li>半连接策略（semi-join）：半连接优化技术，本质上是把子查询上拉到父查询中，与父查询的表做join&#x2F;semi-join的操作</li>
<li>子查询物化策略：物化子查询，子查询的结果通常缓存在内存或临时表中</li>
<li>转换为相关子查询：把半连接转换为EXISTS操作。本质上是把父表的条件下推到子查询</li>
</ul>
<p>如果半连接参数关闭（set optimizer_switch&#x3D;’semijoin&#x3D;off’），则可以使用物化策略或转换为子查询策略，或者如果子查询中存在像 group by 子句这样的限制因素，又或者因为成本问题不能转换为半连接，那就要在物化和转换为子查询策略中二选一了。使用哪种由函数decide_subquery_strategy决定，该函数会调用compare_costs_of_subquery_strategies进行两种策略的代价计算，选择代价小的优化策略。</p>
<p>实际上，compare_costs_of_subquery_strategies会调用optimize_semijoin_nests_for_materialization，这个函数又会调用Optimize_table_order::choose_table_order，对embeding、semijoin的子查询做局部的 join reorder，此时输出结果与considered_execution_plans部分格式相同，我们放在下一节里统一介绍，这里先跳过。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">set</span> optimizer_switch<span class="operator">=</span><span class="string">&#x27;semijoin=off&#x27;</span>;</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">where</span> a <span class="operator">&lt;</span> <span class="number">5</span> <span class="keyword">and</span> a <span class="keyword">in</span> (<span class="keyword">select</span> a <span class="keyword">from</span> t2);</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> information_schema.optimizer_trace\G</span><br><span class="line">...</span><br><span class="line">            &quot;execution_plan_for_potential_materialization&quot;: &#123;                                                                                                                                                                                                                     [<span class="number">90</span><span class="operator">/</span><span class="number">1913</span>]</span><br><span class="line">              &quot;steps&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                  &quot;considered_execution_plans&quot;: [</span><br><span class="line">                    ... # 见下一节</span><br><span class="line">                  ]</span><br><span class="line">                &#125;</span><br><span class="line">              ],</span><br><span class="line">              &quot;subq_mat_decision&quot;: &#123;                                    # 使用物化方式执行子查询的成本</span><br><span class="line">                &quot;parent_fanouts&quot;: [</span><br><span class="line">                  &#123;</span><br><span class="line">                    &quot;select#&quot;: <span class="number">1</span>,</span><br><span class="line">                    &quot;subq_attached_to_table&quot;: <span class="literal">true</span>,</span><br><span class="line">                    &quot;table&quot;: &quot;`t1`&quot;,</span><br><span class="line">                    &quot;fanout&quot;: <span class="number">4</span>,                                        # 表示预估的主查询t1表里满足a <span class="operator">&lt;</span> <span class="number">5</span>的记录数量</span><br><span class="line">                    &quot;cacheable&quot;: <span class="literal">true</span></span><br><span class="line">                  &#125;</span><br><span class="line">                ],</span><br><span class="line">                &quot;cost_to_create_and_fill_materialized_table&quot;: <span class="number">2.249</span>,    # 表示创建临时表的成本，加上把子查询中的所有记录都写入临时表的成本</span><br><span class="line">                &quot;cost_of_one_EXISTS&quot;: <span class="number">0.349</span>,</span><br><span class="line">                &quot;number_of_subquery_evaluations&quot;: <span class="number">4</span>,</span><br><span class="line">                &quot;cost_of_materialization&quot;: <span class="number">2.649</span>,                       # 表示使用物化方式执行 <span class="keyword">IN</span> 子查询的总成本</span><br><span class="line">                &quot;cost_of_EXISTS&quot;: <span class="number">1.396</span>,                                # 转换为相关子查询的执行成本</span><br><span class="line">                &quot;chosen&quot;: <span class="literal">false</span></span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>cost_of_materialization 表示使用物化方式执行 IN 子查询的总成本，计算公式为：</p>
<p><code>cost_of_materialization = cost_to_create_and_fill_materialized_table + number_of_subquery_evaluations * (io_cost + cpu_cost + import_cost)</code></p>
<p>后面括号里的结果可以由该SQL得到：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">  cost_name, cost_value, default_value</span><br><span class="line"><span class="keyword">FROM</span> mysql.server_cost</span><br><span class="line"><span class="keyword">WHERE</span> cost_name <span class="operator">=</span> <span class="string">&#x27;memory_temptable_row_cost&#x27;</span></span><br></pre></td></tr></table></figure>

<p>查询 cost_name 等于 memory_temptable_row_cost 的成本常数，因为使用的是内存临时表。<br>如果子查询使用的是磁盘临时表，则需要查询 cost_name 等于 disk_temptable_row_cost 的成本常数。</p>
<p>cost_of_EXISTS为转换为子查询的执行成本，计算公式为：</p>
<p><code>cost_of_EXISTS = cost_of_one_EXISTS * number_of_subquery_evaluations</code></p>
<h3 id="3-2-9-considered-execution-plans"><a href="#3-2-9-considered-execution-plans" class="headerlink" title="3.2.9 considered_execution_plans"></a>3.2.9 considered_execution_plans</h3><p>considered_execution_plans对应sql&#x2F;sql_planner.cc的Optimize_table_order::choose_table_order函数，负责对比各可行计划的开销，并选择相对最优的执行计划。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">considered_execution_plans&#123; ：对比各可行计划的代价，选择相对最优的执行计划</span><br><span class="line">  plan_prefix：前置的执行计划</span><br><span class="line">  table：涉及的表名，如果有别名，也会展示出来</span><br><span class="line">  best_access_path：当前最优的执行顺序信息结果集。通过对比considered_access_paths，选择一个最优的访问路径</span><br><span class="line">    considered_access_paths：当前考虑的访问路径</span><br><span class="line">      access_type：表示使用索引的方式，可参照为explain中的type字段</span><br><span class="line">      index：索引</span><br><span class="line">      rows：行数</span><br><span class="line">      cost：开销</span><br><span class="line">      chosen：是否选择这种执行路径</span><br><span class="line">  condition_filtering_pct：类似于explain中的filtered列，这是一个估算值</span><br><span class="line">  rows_for_plan：该执行计划最终的扫描行数，这里的行数其实也是估算值，是由considered_access_paths的resulting_rows相乘之后再乘以condition_filtering_pct获得</span><br><span class="line">  cost_for_plan：该执行计划的执行代价，由considered_access_paths的cost相加而得</span><br><span class="line">  chosen：是否选择了该执行计划</span><br><span class="line">  rest_of_plan：多表之间的JOIN会出现该部分，来分析被驱动表的代价，来确定多表之间的JOIN顺序。如果是三表JOIN则rest_of_plan下还会存在下级的rest_of_plan</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>单表场景只会考虑Range和Ref的访问方式（Ref access vs. table&#x2F;index scan）：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"># <span class="keyword">table</span> scan</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t3  <span class="keyword">where</span> b<span class="operator">=</span><span class="number">5</span>; # (<span class="keyword">no</span> index <span class="keyword">on</span> b)</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> information_schema.optimizer_trace\G</span><br><span class="line">...</span><br><span class="line">            &quot;considered_execution_plans&quot;: [</span><br><span class="line">              &#123;</span><br><span class="line">                &quot;plan_prefix&quot;: [</span><br><span class="line">                ],</span><br><span class="line">                &quot;table&quot;: &quot;`t3`&quot;,</span><br><span class="line">                &quot;best_access_path&quot;: &#123;</span><br><span class="line">                  &quot;considered_access_paths&quot;: [</span><br><span class="line">                    &#123;</span><br><span class="line">                      &quot;rows_to_scan&quot;: <span class="number">5</span>,</span><br><span class="line">                      &quot;access_type&quot;: &quot;scan&quot;,</span><br><span class="line">                      &quot;resulting_rows&quot;: <span class="number">5</span>,</span><br><span class="line">                      &quot;cost&quot;: <span class="number">0.75</span>,</span><br><span class="line">                      &quot;chosen&quot;: <span class="literal">true</span></span><br><span class="line">                    &#125;</span><br><span class="line">                  ]</span><br><span class="line">                &#125;,</span><br><span class="line">                &quot;condition_filtering_pct&quot;: <span class="number">100</span>,</span><br><span class="line">                &quot;rows_for_plan&quot;: <span class="number">5</span>,</span><br><span class="line">                &quot;cost_for_plan&quot;: <span class="number">0.75</span>,</span><br><span class="line">                &quot;chosen&quot;: <span class="literal">true</span></span><br><span class="line">              &#125;</span><br><span class="line">            ]</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"># <span class="keyword">ref</span> access</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> c, d <span class="keyword">from</span> t5 <span class="keyword">where</span> c <span class="operator">=</span> <span class="number">5</span> <span class="keyword">and</span> d <span class="operator">=</span> <span class="number">5</span>; # index(c, d)</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> information_schema.optimizer_trace\G</span><br><span class="line">...</span><br><span class="line">            &quot;considered_execution_plans&quot;: [</span><br><span class="line">              &#123;</span><br><span class="line">                &quot;plan_prefix&quot;: [</span><br><span class="line">                ],</span><br><span class="line">                &quot;table&quot;: &quot;`t5`&quot;,</span><br><span class="line">                &quot;best_access_path&quot;: &#123;</span><br><span class="line">                  &quot;considered_access_paths&quot;: [</span><br><span class="line">                    &#123;</span><br><span class="line">                      &quot;access_type&quot;: &quot;ref&quot;,</span><br><span class="line">                      &quot;index&quot;: &quot;kcd&quot;,</span><br><span class="line">                      &quot;rows&quot;: <span class="number">1</span>,</span><br><span class="line">                      &quot;cost&quot;: <span class="number">0.35</span>,</span><br><span class="line">                      &quot;chosen&quot;: <span class="literal">true</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                      &quot;access_type&quot;: &quot;range&quot;,</span><br><span class="line">                      &quot;range_details&quot;: &#123;</span><br><span class="line">                        &quot;used_index&quot;: &quot;kcd&quot;</span><br><span class="line">                      &#125;,</span><br><span class="line">                      &quot;chosen&quot;: <span class="literal">false</span>,</span><br><span class="line">                      &quot;cause&quot;: &quot;heuristic_index_cheaper&quot;</span><br><span class="line">                    &#125;</span><br><span class="line">                  ]</span><br><span class="line">                &#125;,</span><br><span class="line">                &quot;condition_filtering_pct&quot;: <span class="number">100</span>,</span><br><span class="line">                &quot;rows_for_plan&quot;: <span class="number">1</span>,</span><br><span class="line">                &quot;cost_for_plan&quot;: <span class="number">0.35</span>,</span><br><span class="line">                &quot;chosen&quot;: <span class="literal">true</span></span><br><span class="line">              &#125;</span><br><span class="line">            ]</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"># <span class="keyword">range</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> b <span class="keyword">from</span> t5 <span class="keyword">where</span> b <span class="operator">&gt;</span> <span class="number">3</span> <span class="keyword">and</span> b <span class="operator">&lt;</span> <span class="number">5</span>; # index(b)</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> information_schema.optimizer_trace\G</span><br><span class="line">...</span><br><span class="line">            &quot;considered_execution_plans&quot;: [</span><br><span class="line">              &#123;</span><br><span class="line">                &quot;plan_prefix&quot;: [</span><br><span class="line">                ],</span><br><span class="line">                &quot;table&quot;: &quot;`t5`&quot;,</span><br><span class="line">                &quot;best_access_path&quot;: &#123;</span><br><span class="line">                  &quot;considered_access_paths&quot;: [</span><br><span class="line">                    &#123;</span><br><span class="line">                      &quot;rows_to_scan&quot;: <span class="number">1</span>,</span><br><span class="line">                      &quot;access_type&quot;: &quot;range&quot;,</span><br><span class="line">                      &quot;range_details&quot;: &#123;</span><br><span class="line">                        &quot;used_index&quot;: &quot;kb&quot;</span><br><span class="line">                      &#125;,</span><br><span class="line">                      &quot;resulting_rows&quot;: <span class="number">1</span>,</span><br><span class="line">                      &quot;cost&quot;: <span class="number">0.46</span>,</span><br><span class="line">                      &quot;chosen&quot;: <span class="literal">true</span></span><br><span class="line">                    &#125;</span><br><span class="line">                  ]</span><br><span class="line">                &#125;,</span><br><span class="line">                &quot;condition_filtering_pct&quot;: <span class="number">100</span>,</span><br><span class="line">                &quot;rows_for_plan&quot;: <span class="number">1</span>,</span><br><span class="line">                &quot;cost_for_plan&quot;: <span class="number">0.46</span>,</span><br><span class="line">                &quot;chosen&quot;: <span class="literal">true</span></span><br><span class="line">              &#125;</span><br><span class="line">            ]</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>如果多表还要进行贪婪算法，选出最有的连接顺序和方法。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">join</span> t2 <span class="keyword">on</span> t1.a<span class="operator">=</span>t2.a;</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> information_schema.optimizer_trace\G</span><br><span class="line"># 这里会出现两部分，第一部分是t1做驱动表，t2做被驱动表，此时rest_of_plan会记录t2的代价；另一部分就是t2做驱动表</span><br><span class="line"># 驱动表的分析及格式和单表场景一样，rest_of_plan也具有同样的格式</span><br><span class="line"># 这里只给出一个rest_of_plan的例子</span><br><span class="line">...</span><br><span class="line">                &quot;rest_of_plan&quot;: [</span><br><span class="line">                  &#123;</span><br><span class="line">                    &quot;plan_prefix&quot;: [</span><br><span class="line">                      &quot;`t2`&quot;</span><br><span class="line">                    ],</span><br><span class="line">                    &quot;table&quot;: &quot;`t1`&quot;,</span><br><span class="line">                    &quot;best_access_path&quot;: &#123;</span><br><span class="line">                      &quot;considered_access_paths&quot;: [</span><br><span class="line">                        &#123;</span><br><span class="line">                          &quot;access_type&quot;: &quot;eq_ref&quot;,</span><br><span class="line">                          &quot;index&quot;: &quot;PRIMARY&quot;,</span><br><span class="line">                          &quot;rows&quot;: <span class="number">1</span>,</span><br><span class="line">                          &quot;cost&quot;: <span class="number">1.75</span>,</span><br><span class="line">                          &quot;chosen&quot;: <span class="literal">true</span>,</span><br><span class="line">                          &quot;cause&quot;: &quot;clustered_pk_chosen_by_heuristics&quot;</span><br><span class="line">                        &#125;,</span><br><span class="line">                        &#123;</span><br><span class="line">                          &quot;rows_to_scan&quot;: <span class="number">5</span>,</span><br><span class="line">                          &quot;filtering_effect&quot;: [</span><br><span class="line">                          ],</span><br><span class="line">                          &quot;final_filtering_effect&quot;: <span class="number">1</span>,</span><br><span class="line">                          &quot;access_type&quot;: &quot;scan&quot;,</span><br><span class="line">                          &quot;using_join_cache&quot;: <span class="literal">true</span>,</span><br><span class="line">                          &quot;buffers_needed&quot;: <span class="number">1</span>,</span><br><span class="line">                          &quot;resulting_rows&quot;: <span class="number">5</span>,</span><br><span class="line">                          &quot;cost&quot;: <span class="number">2.75</span>,</span><br><span class="line">                          &quot;chosen&quot;: <span class="literal">false</span></span><br><span class="line">                        &#125;</span><br><span class="line">                      ]</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>通过在驱动表上做额外的where条件过滤（Condition Filtering），能够将驱动表限制在一个更小的范围，以便优化器能够做出更优的执行计划。如果有条件过滤中的where条件不在索引条件中，并且有表连接的场景，还可以关注filtering_effect的值，通过set optimizer_switch&#x3D;”condition_fanout_filter&#x3D;on”;可以关闭该优化。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> t1.a <span class="keyword">from</span> t1 <span class="keyword">where</span> <span class="keyword">exists</span>(</span><br><span class="line">          <span class="keyword">select</span> <span class="number">1</span> <span class="keyword">from</span> t2 <span class="keyword">inner</span> <span class="keyword">join</span> t3 <span class="keyword">on</span> t3.a <span class="operator">=</span>t2.a</span><br><span class="line">                            <span class="keyword">inner</span> <span class="keyword">join</span> t4 <span class="keyword">on</span> t4.a <span class="operator">=</span> t3.a </span><br><span class="line">                              <span class="keyword">inner</span> <span class="keyword">join</span> t1 <span class="keyword">on</span> t1.a <span class="operator">=</span> t4.a</span><br><span class="line">          <span class="keyword">where</span> t1.a <span class="operator">=</span> t4.a <span class="keyword">and</span> t2.b<span class="operator">&gt;</span><span class="number">0</span>);</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> information_schema.optimizer_trace\G</span><br><span class="line">...</span><br><span class="line">                  &quot;considered_execution_plans&quot;: [</span><br><span class="line">                    &#123;</span><br><span class="line">                      &quot;plan_prefix&quot;: [</span><br><span class="line">                      ],</span><br><span class="line">                      &quot;table&quot;: &quot;`t2`&quot;,</span><br><span class="line">                      &quot;best_access_path&quot;: &#123;</span><br><span class="line">                        &quot;considered_access_paths&quot;: [</span><br><span class="line">                          ...</span><br><span class="line">                          &#123;</span><br><span class="line">                            &quot;rows_to_scan&quot;: <span class="number">5</span>,</span><br><span class="line">                            &quot;filtering_effect&quot;: [</span><br><span class="line">                            ],</span><br><span class="line">                            &quot;final_filtering_effect&quot;: <span class="number">1</span>,</span><br><span class="line">                            &quot;access_type&quot;: &quot;range&quot;,</span><br><span class="line">                            &quot;range_details&quot;: &#123;</span><br><span class="line">                              &quot;used_index&quot;: &quot;kb&quot;</span><br><span class="line">                            &#125;,</span><br><span class="line">                            &quot;resulting_rows&quot;: <span class="number">5</span>,</span><br><span class="line">                            &quot;cost&quot;: <span class="number">2.51</span>,</span><br><span class="line">                            &quot;chosen&quot;: <span class="literal">true</span></span><br><span class="line">                          &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>semi-join的优化也会显示在这里。semi-join一般有五种策略分别是FirstMatch、LooseScan、MaterializeLookup、MaterializeScan、DuplicatesWeedout。可以通过<code>set @@optimizer_switch=&#39;materialization=on,semijoin=on,loosescan=on,firstmatch=on,duplicateweedout=on,subquery_materialization_cost_based=on&#39;;</code>来强制关闭某种策略。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> t1.a <span class="keyword">from</span> t1 <span class="keyword">where</span> <span class="keyword">exists</span>(</span><br><span class="line">          <span class="keyword">select</span> <span class="number">1</span> <span class="keyword">from</span> t2 <span class="keyword">inner</span> <span class="keyword">join</span> t3 <span class="keyword">on</span> t3.a <span class="operator">=</span>t2.a</span><br><span class="line">                            <span class="keyword">inner</span> <span class="keyword">join</span> t4 <span class="keyword">on</span> t4.a <span class="operator">=</span> t3.a </span><br><span class="line">                              <span class="keyword">inner</span> <span class="keyword">join</span> t1 <span class="keyword">on</span> t1.a <span class="operator">=</span> t4.a</span><br><span class="line">          <span class="keyword">where</span> t1.a <span class="operator">=</span> t4.a <span class="keyword">and</span> t2.b<span class="operator">&gt;</span><span class="number">0</span>);</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> information_schema.optimizer_trace\G</span><br><span class="line">...</span><br><span class="line">                                &quot;semijoin_strategy_choice&quot;: [</span><br><span class="line">                                  &#123;</span><br><span class="line">                                    &quot;strategy&quot;: &quot;FirstMatch&quot;,</span><br><span class="line">                                    &quot;recalculate_access_paths_and_cost&quot;: &#123;</span><br><span class="line">                                      &quot;tables&quot;: [</span><br><span class="line">                                        &#123;</span><br><span class="line">                                          &quot;table&quot;: &quot;`t2`&quot;,</span><br><span class="line">                                          &quot;best_access_path&quot;: &#123;</span><br><span class="line">                                            &quot;considered_access_paths&quot;: [</span><br><span class="line">                                              &#123;</span><br><span class="line">                                                &quot;access_type&quot;: &quot;ref&quot;,</span><br><span class="line">                                                &quot;index&quot;: &quot;ka&quot;,</span><br><span class="line">                                                &quot;usable&quot;: <span class="literal">false</span>,</span><br><span class="line">                                                &quot;chosen&quot;: <span class="literal">false</span></span><br><span class="line">                                              &#125;,</span><br><span class="line">                                              &#123;</span><br><span class="line">                                                &quot;access_type&quot;: &quot;ref&quot;,</span><br><span class="line">                                                &quot;index&quot;: &quot;primary_key&quot;,</span><br><span class="line">                                                &quot;usable&quot;: <span class="literal">false</span>,</span><br><span class="line">                                                &quot;chosen&quot;: <span class="literal">false</span></span><br><span class="line">                                              &#125;,</span><br><span class="line">                                              &#123;</span><br><span class="line">                                                &quot;rows_to_scan&quot;: <span class="number">5</span>,</span><br><span class="line">                                                &quot;filtering_effect&quot;: [</span><br><span class="line">                                                ],</span><br><span class="line">                                                &quot;final_filtering_effect&quot;: <span class="number">1</span>,</span><br><span class="line">                                                &quot;access_type&quot;: &quot;range&quot;,</span><br><span class="line">                                                &quot;range_details&quot;: &#123;</span><br><span class="line">                                                  &quot;used_index&quot;: &quot;kb&quot;</span><br><span class="line">                                                &#125;,</span><br><span class="line">                                                &quot;resulting_rows&quot;: <span class="number">5</span>,</span><br><span class="line">                                                &quot;cost&quot;: <span class="number">12.55</span>,</span><br><span class="line">                                                &quot;chosen&quot;: <span class="literal">true</span></span><br><span class="line">                                              &#125;</span><br><span class="line">                                            ]</span><br><span class="line">                                          &#125;</span><br><span class="line">                                        &#125;</span><br><span class="line">                                      ]</span><br><span class="line">                                    &#125;,</span><br><span class="line">                                    &quot;cost&quot;: <span class="number">24.55</span>,</span><br><span class="line">                                    &quot;rows&quot;: <span class="number">5</span>,</span><br><span class="line">                                    &quot;chosen&quot;: <span class="literal">true</span></span><br><span class="line">                                  &#125;,</span><br><span class="line">                                  &#123;</span><br><span class="line">                                    &quot;strategy&quot;: &quot;MaterializeLookup&quot;,</span><br><span class="line">                                    &quot;cost&quot;: <span class="number">8.75</span>,</span><br><span class="line">                                    &quot;rows&quot;: <span class="number">5</span>,</span><br><span class="line">                                    &quot;duplicate_tables_left&quot;: <span class="literal">false</span>,</span><br><span class="line">                                    &quot;chosen&quot;: <span class="literal">true</span></span><br><span class="line">                                  &#125;,</span><br><span class="line">                                  &#123;</span><br><span class="line">                                    &quot;strategy&quot;: &quot;DuplicatesWeedout&quot;,</span><br><span class="line">                                    &quot;cost&quot;: <span class="number">28.55</span>,</span><br><span class="line">                                    &quot;rows&quot;: <span class="number">5</span>,</span><br><span class="line">                                    &quot;duplicate_tables_left&quot;: <span class="literal">false</span>,</span><br><span class="line">                                    &quot;chosen&quot;: <span class="literal">false</span></span><br><span class="line">                                  &#125;</span><br><span class="line">                                ]</span><br><span class="line">...</span><br><span class="line">              &#123;</span><br><span class="line">                &quot;final_semijoin_strategy&quot;: &quot;MaterializeLookup&quot;</span><br><span class="line">              &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h3 id="3-2-10-creating-tmp-table"><a href="#3-2-10-creating-tmp-table" class="headerlink" title="3.2.10 creating_tmp_table"></a>3.2.10 creating_tmp_table</h3><p>derived table物化需要创建临时表，物化derived table时会执行Query_block::execute()，因此也会出现这个信息（本来应该在join_execute中的）。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">creating_tmp_table：&#123;</span><br><span class="line">  tmp_table_info：临时表信息</span><br><span class="line">    table：临时表的名称</span><br><span class="line">    columns：临时表的列数</span><br><span class="line">    row_length：临时表的单行长度</span><br><span class="line">    key_length：临时表索引长度</span><br><span class="line">    unique_constraint：是否有使用唯一约束</span><br><span class="line">    makes_grouped_rows：是否有GROUP BY</span><br><span class="line">    cannot_insert_duplicates：是否是distinct</span><br><span class="line">    location：表的类型，比如内存表memory (heap)，TempTable（TempTable），或者是转换到磁盘的物理表disk (InnoDB)</span><br><span class="line">    row_limit_estimate：该临时表中能存储的最大行数，如果是MEMORY表，会出现该记录</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>example:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> t1.a <span class="keyword">from</span> t1 <span class="keyword">where</span> <span class="keyword">exists</span>(</span><br><span class="line">          <span class="keyword">select</span> <span class="number">1</span> <span class="keyword">from</span> t2 <span class="keyword">inner</span> <span class="keyword">join</span> t3 <span class="keyword">on</span> t3.a <span class="operator">=</span>t2.a</span><br><span class="line">                            <span class="keyword">inner</span> <span class="keyword">join</span> t4 <span class="keyword">on</span> t4.a <span class="operator">=</span> t3.a </span><br><span class="line">                              <span class="keyword">inner</span> <span class="keyword">join</span> t1 <span class="keyword">on</span> t1.a <span class="operator">=</span> t4.a</span><br><span class="line">          <span class="keyword">where</span> t1.a <span class="operator">=</span> t4.a <span class="keyword">and</span> t2.b<span class="operator">&gt;</span><span class="number">0</span>);</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> information_schema.optimizer_trace\G</span><br><span class="line">...</span><br><span class="line">            &quot;creating_tmp_table&quot;: &#123;</span><br><span class="line">              &quot;tmp_table_info&quot;: &#123;</span><br><span class="line">                &quot;table&quot;: &quot;&lt;subquery2&gt;&quot;,</span><br><span class="line">                &quot;columns&quot;: <span class="number">1</span>,</span><br><span class="line">                &quot;row_length&quot;: <span class="number">9</span>,</span><br><span class="line">                &quot;key_length&quot;: <span class="number">8</span>,</span><br><span class="line">                &quot;unique_constraint&quot;: <span class="literal">false</span>,</span><br><span class="line">                &quot;makes_grouped_rows&quot;: <span class="literal">false</span>,</span><br><span class="line">                &quot;cannot_insert_duplicates&quot;: <span class="literal">true</span>,</span><br><span class="line">                &quot;location&quot;: &quot;TempTable&quot;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h3 id="3-2-11-attaching-conditions-to-tables"><a href="#3-2-11-attaching-conditions-to-tables" class="headerlink" title="3.2.11 attaching_conditions_to_tables"></a>3.2.11 attaching_conditions_to_tables</h3><p>attaching_conditions_to_tables对应sql&#x2F;sql_optimizer.cc的make_join_query_block函数。这一部分基于considered_execution_plans中选择的执行计划，改造原有where条件，并针对表增加适当的附加条件，以便于单表数据的筛选。</p>
<p>这部分条件的增加主要是为了便于ICP（索引条件下推），但ICP是否开启并不影响这部分内容的构造。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">attaching_conditions_to_tables: &#123;</span><br><span class="line">  original_condition: 原始的条件语句</span><br><span class="line">  attached_conditions_computation： 使用启发式算法计算已使用的索引，如果已使用的索引的访问类型是ref，则计算用range能否使用组合索引中更多的列，如果可以，则用range的方式替换ref</span><br><span class="line">  attached_conditions_summary: 附加之后的情况汇总</span><br><span class="line">      table: 表名</span><br><span class="line">      attached: 附加的条件或原语句中能直接下推给单表筛选的条件</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>example:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> b <span class="keyword">from</span> t5 <span class="keyword">where</span> b <span class="operator">&gt;</span> <span class="number">3</span> <span class="keyword">and</span> b <span class="operator">&lt;</span> <span class="number">5</span>;</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> information_schema.optimizer_trace\G</span><br><span class="line">...</span><br><span class="line">            &quot;attaching_conditions_to_tables&quot;: &#123;</span><br><span class="line">              &quot;original_condition&quot;: &quot;((`t5`.`b` &gt; 3) and (`t5`.`b` &lt; 5))&quot;,</span><br><span class="line">              &quot;attached_conditions_computation&quot;: [</span><br><span class="line">              ],</span><br><span class="line">              &quot;attached_conditions_summary&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                  &quot;table&quot;: &quot;`t5`&quot;,</span><br><span class="line">                  &quot;attached&quot;: &quot;((`t5`.`b` &gt; 3) and (`t5`.`b` &lt; 5))&quot;</span><br><span class="line">                &#125;</span><br><span class="line">              ]</span><br><span class="line">            &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h3 id="3-2-12-optimizing-distinct-group-by-order-by"><a href="#3-2-12-optimizing-distinct-group-by-order-by" class="headerlink" title="3.2.12 optimizing_distinct_group_by_order_by"></a>3.2.12 optimizing_distinct_group_by_order_by</h3><p>optimizing_distinct_group_by_order_by对应sql&#x2F;sql_optimizer.cc的JOIN::optimize_distinct_group_order函数，用于优化DISTINCT，GROUP BY、ORDER BY子句，例如将 distinct 转换为 group by，消除不必要的 trivial order by 等。</p>
<p>给出三个example，这一过程比较易读，不多解释：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"># 消除不必要的<span class="keyword">distinct</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="keyword">distinct</span> a <span class="keyword">from</span> t5; # <span class="keyword">primary</span> key(a)</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> information_schema.optimizer_trace\G</span><br><span class="line">...</span><br><span class="line">            &quot;optimizing_distinct_group_by_order_by&quot;: &#123;</span><br><span class="line">              &quot;distinct_is_on_unique&quot;: <span class="literal">true</span>,</span><br><span class="line">              &quot;removed_distinct&quot;: <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"># <span class="keyword">distinct</span>转为<span class="keyword">order</span> <span class="keyword">by</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="keyword">distinct</span> b <span class="keyword">from</span> t5;</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> information_schema.optimizer_trace\G</span><br><span class="line">...</span><br><span class="line">            &quot;optimizing_distinct_group_by_order_by&quot;: &#123;</span><br><span class="line">              &quot;changed_distinct_to_group_by&quot;: <span class="literal">true</span>,</span><br><span class="line">              &quot;simplifying_group_by&quot;: &#123;</span><br><span class="line">                &quot;original_clause&quot;: &quot;`t5`.`b`&quot;,</span><br><span class="line">                &quot;items&quot;: [</span><br><span class="line">                  &#123;</span><br><span class="line">                    &quot;item&quot;: &quot;`t5`.`b`&quot;</span><br><span class="line">                  &#125;</span><br><span class="line">                ],</span><br><span class="line">                &quot;resulting_clause_is_simple&quot;: <span class="literal">true</span>,</span><br><span class="line">                &quot;resulting_clause&quot;: &quot;`t5`.`b`&quot;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"># 简化<span class="keyword">order</span> <span class="keyword">by</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> b <span class="keyword">from</span> t5 <span class="keyword">where</span> b <span class="operator">&gt;</span> <span class="number">3</span> <span class="keyword">and</span> b <span class="operator">&lt;</span> <span class="number">5</span> <span class="keyword">order</span> <span class="keyword">by</span> d;</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> information_schema.optimizer_trace\G</span><br><span class="line">...</span><br><span class="line">            &quot;optimizing_distinct_group_by_order_by&quot;: &#123;</span><br><span class="line">              &quot;simplifying_order_by&quot;: &#123;</span><br><span class="line">                &quot;original_clause&quot;: &quot;`t5`.`d`&quot;,</span><br><span class="line">                &quot;items&quot;: [</span><br><span class="line">                  &#123;</span><br><span class="line">                    &quot;item&quot;: &quot;`t5`.`d`&quot;</span><br><span class="line">                  &#125;</span><br><span class="line">                ],</span><br><span class="line">                &quot;resulting_clause_is_simple&quot;: <span class="literal">true</span>,</span><br><span class="line">                &quot;resulting_clause&quot;: &quot;`t5`.`d`&quot;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h3 id="3-2-13-reconsidering-access-paths-for-index-ordering"><a href="#3-2-13-reconsidering-access-paths-for-index-ordering" class="headerlink" title="3.2.13 reconsidering_access_paths_for_index_ordering"></a>3.2.13 reconsidering_access_paths_for_index_ordering</h3><p>reconsidering_access_paths_for_index_ordering对应sql&#x2F;sql_optimizer.cc中的函数test_if_skip_sort_order，表示最终对排序再进行一次索引选择优化。<br>如果使用了order by asc这种排序写法，优化器认为排序是个昂贵的操作，所以为了避免排序，如果order by引用的列上有索引，它认为limit n的n很小的话，基于这个索引做index scan也能很快执行完，就会选择index scan。</p>
<p>实际上，这个优化是有bug的：</p>
<p><a target="_blank" rel="noopener" href="https://bugs.mysql.com/bug.php?id=100257">Optimizer chooses wrong index for ORDER BY LIMIT</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/413950988">这个 MySQL bug 99% 的人会踩坑!</a></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> c,a <span class="keyword">from</span> t5 <span class="keyword">where</span> c <span class="operator">&gt;</span> <span class="number">0</span> <span class="keyword">and</span> c <span class="operator">&lt;</span> <span class="number">5</span> <span class="keyword">order</span> <span class="keyword">by</span> a; # primary_key(a), index(c,b)</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> information_schema.optimizer_trace\G</span><br><span class="line">...</span><br><span class="line">            &quot;reconsidering_access_paths_for_index_ordering&quot;: &#123;</span><br><span class="line">              &quot;clause&quot;: &quot;ORDER BY&quot;,</span><br><span class="line">              &quot;steps&quot;: [</span><br><span class="line">              ],</span><br><span class="line">              &quot;index_order_summary&quot;: &#123;</span><br><span class="line">                &quot;table&quot;: &quot;`t5`&quot;,</span><br><span class="line">                &quot;index_provides_order&quot;: <span class="literal">true</span>,</span><br><span class="line">                &quot;order_direction&quot;: &quot;asc&quot;,</span><br><span class="line">                &quot;index&quot;: &quot;PRIMARY&quot;,</span><br><span class="line">                &quot;plan_changed&quot;: <span class="literal">true</span>,</span><br><span class="line">                &quot;access_type&quot;: &quot;index&quot;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h3 id="3-2-14-finalizing-table-conditions"><a href="#3-2-14-finalizing-table-conditions" class="headerlink" title="3.2.14 finalizing_table_conditions"></a>3.2.14 finalizing_table_conditions</h3><p>finalizing_table_conditions对应sql&#x2F;sql_optimizer.cc的函数JOIN::finalize_table_conditions，负责进行最后一轮的 condition 优化，这一步主要是去除冗余的 filter，将缓存表达式中的常量，避免每一行数据都重新计算等，得到最终的、经过优化后的表条件。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> t1.a <span class="keyword">from</span> t1 <span class="keyword">where</span> <span class="keyword">exists</span>(</span><br><span class="line">          <span class="keyword">select</span> <span class="number">1</span> <span class="keyword">from</span> t2 <span class="keyword">inner</span> <span class="keyword">join</span> t3 <span class="keyword">on</span> t3.a <span class="operator">=</span>t2.a</span><br><span class="line">                            <span class="keyword">inner</span> <span class="keyword">join</span> t4 <span class="keyword">on</span> t4.a <span class="operator">=</span> t3.a </span><br><span class="line">                              <span class="keyword">inner</span> <span class="keyword">join</span> t1 <span class="keyword">on</span> t1.a <span class="operator">=</span> t4.a</span><br><span class="line">          <span class="keyword">where</span> t1.a <span class="operator">=</span> t4.a <span class="keyword">and</span> t2.b<span class="operator">&gt;</span><span class="number">0</span>);</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> information_schema.optimizer_trace\G</span><br><span class="line">...</span><br><span class="line">            &quot;finalizing_table_conditions&quot;: [</span><br><span class="line">              &#123;</span><br><span class="line">                &quot;table&quot;: &quot;`t2`&quot;,</span><br><span class="line">                &quot;original_table_condition&quot;: &quot;((`t2`.`a` = `t3`.`a`) and (`t2`.`b` &gt; 0))&quot;,</span><br><span class="line">                &quot;final_table_condition   &quot;: &quot;(`t2`.`b` &gt; 0)&quot;</span><br><span class="line">              &#125;,</span><br><span class="line">              &#123;</span><br><span class="line">                &quot;table&quot;: &quot;`t4`&quot;,</span><br><span class="line">                &quot;original_table_condition&quot;: &quot;(`t4`.`a` = `t3`.`a`)&quot;,</span><br><span class="line">                &quot;final_table_condition   &quot;: <span class="keyword">null</span></span><br><span class="line">              &#125;,</span><br><span class="line">              &#123;</span><br><span class="line">                &quot;table&quot;: &quot;`t1`&quot;,</span><br><span class="line">                &quot;original_table_condition&quot;: &quot;(`t1`.`a` = `t3`.`a`)&quot;,</span><br><span class="line">                &quot;final_table_condition   &quot;: <span class="keyword">null</span></span><br><span class="line">              &#125;</span><br><span class="line">            ]</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h3 id="3-2-15-refine-plan"><a href="#3-2-15-refine-plan" class="headerlink" title="3.2.15 refine_plan"></a>3.2.15 refine_plan</h3><p>refine_plan对应sql&#x2F;sql_select.cc的函数make_join_readinfo，负责改善执行计划，做执行前的 plan 调整，比如分配 join buffer、index条件下推等。</p>
<p>如果只展示了对应的表对象没有其他的字段的话，说明在之前已经确定的执行计划中没有需要再优化的地方，可直接应用。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">table</span>: &#123; 涉及的表名及其别名</span><br><span class="line">  pushed_index_condition: 可使用到ICP的条件句</span><br><span class="line">  table_condition_attached: 在attaching_conditions_to_tables阶段添加了附加条件的条件语句</span><br><span class="line">  access_type: 优化后的索引访问类型</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-16-considering-tmp-tables"><a href="#3-2-16-considering-tmp-tables" class="headerlink" title="3.2.16 considering_tmp_tables"></a>3.2.16 considering_tmp_tables</h3><p>considering_tmp_tables对应sql&#x2F;sql_select.cc的函数JOIN::make_tmp_tables_info，这是 MySQL 查询优化的最后一步，为执行计划中各个 SQL 算子按需分配 tmp table。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> a, <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> t1_count <span class="keyword">from</span> t1 <span class="keyword">where</span> <span class="keyword">exists</span> (<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t2 <span class="keyword">where</span> a<span class="operator">=</span>b <span class="keyword">and</span> a <span class="operator">&lt;</span> c) <span class="keyword">group</span> <span class="keyword">by</span> a <span class="keyword">order</span> <span class="keyword">by</span> a;</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> information_schema.optimizer_trace\G</span><br><span class="line">...</span><br><span class="line">            &quot;considering_tmp_tables&quot;: [</span><br><span class="line">              &#123;</span><br><span class="line">                &quot;adding_tmp_table_in_plan_at_position&quot;: <span class="number">2</span>,</span><br><span class="line">                &quot;write_method&quot;: &quot;continuously_update_group_row&quot;</span><br><span class="line">              &#125;,</span><br><span class="line">              &#123;</span><br><span class="line">                &quot;adding_sort_to_table&quot;: &quot;&quot;</span><br><span class="line">              &#125;</span><br><span class="line">            ]</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h2 id="3-3-join-execution"><a href="#3-3-join-execution" class="headerlink" title="3.3 join_execution"></a>3.3 join_execution</h2><p>join_execution段落展示了执行阶段的执行过程，trace有三大部分构成，其中join_preparation、join_optimization可以分析explain的过程，但是在join_execution阶段，如果分析的语句是explain的话，该阶段的代码是空结构体，只有在真正执行语句之后，该阶段的代码才会有具体的步骤过程。</p>
<p>join_execution主要分为两部分：</p>
<ul>
<li>临时表信息</li>
<li>排序信息</li>
</ul>
<h3 id="3-3-1-临时表信息"><a href="#3-3-1-临时表信息" class="headerlink" title="3.3.1 临时表信息"></a>3.3.1 临时表信息</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">creating_tmp_table：&#123;</span><br><span class="line">  tmp_table_info：临时表信息</span><br><span class="line">    table：临时表的名称</span><br><span class="line">    columns：临时表的列数</span><br><span class="line">    row_length：临时表的单行长度</span><br><span class="line">    key_length：临时表索引长度</span><br><span class="line">    unique_constraint：是否有使用唯一约束</span><br><span class="line">    makes_grouped_rows：是否有GROUP BY</span><br><span class="line">    cannot_insert_duplicates：是否是distinct</span><br><span class="line">    location：表的类型，比如内存表memory (heap)，TempTable（TempTable），或者是转换到磁盘的物理表disk (InnoDB)</span><br><span class="line">    row_limit_estimate：该临时表中能存储的最大行数，如果是MEMORY表，会出现该记录</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果临时表的大小超过了设置的max_heap_table_size或者是tmp_table_size参数的话，会在此步骤后引发多一个步骤：converting_tmp_table_to_ondisk（将临时表落地到磁盘中），这里没有展示。</p>
<p>example：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">set</span> optimizer_switch<span class="operator">=</span><span class="string">&#x27;derived_merge=off&#x27;</span>;</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> (<span class="keyword">select</span> a <span class="keyword">from</span> t1) tt;</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> information_schema.optimizer_trace\G</span><br><span class="line">...</span><br><span class="line">            &quot;creating_tmp_table&quot;: &#123;</span><br><span class="line">              &quot;tmp_table_info&quot;: &#123;</span><br><span class="line">                &quot;table&quot;: &quot;tt&quot;,</span><br><span class="line">                &quot;in_plan_at_position&quot;: <span class="number">0</span>,</span><br><span class="line">                &quot;columns&quot;: <span class="number">1</span>,</span><br><span class="line">                &quot;row_length&quot;: <span class="number">5</span>,</span><br><span class="line">                &quot;key_length&quot;: <span class="number">0</span>,</span><br><span class="line">                &quot;unique_constraint&quot;: <span class="literal">false</span>,</span><br><span class="line">                &quot;makes_grouped_rows&quot;: <span class="literal">false</span>,</span><br><span class="line">                &quot;cannot_insert_duplicates&quot;: <span class="literal">false</span>,</span><br><span class="line">                &quot;location&quot;: &quot;TempTable&quot;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;materialize&quot;: &#123;</span><br><span class="line">              &quot;select#&quot;: <span class="number">2</span>,</span><br><span class="line">              &quot;steps&quot;: [</span><br><span class="line">              ]</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h3 id="3-3-2-排序信息"><a href="#3-3-2-排序信息" class="headerlink" title="3.3.2 排序信息"></a>3.3.2 排序信息</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">filesort_information：排序的基本信息 </span><br><span class="line">filesort_priority_queue_optimization 是否用到优先级队列堆排序的优化，通常LIMIT会用到该优化 </span><br><span class="line">filesort_execution 文件排序执行 </span><br><span class="line">filesort_summary 排序用到的内存情况和大小 </span><br></pre></td></tr></table></figure>

<p>example:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> b <span class="keyword">from</span> t1 <span class="keyword">order</span> <span class="keyword">by</span> b <span class="keyword">desc</span> limit <span class="number">3</span>;</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> information_schema.optimizer_trace\G</span><br><span class="line">...</span><br><span class="line">            &quot;sorting_table&quot;: &quot;t1&quot;,</span><br><span class="line">            &quot;filesort_information&quot;: [</span><br><span class="line">              &#123;</span><br><span class="line">                &quot;direction&quot;: &quot;desc&quot;,</span><br><span class="line">                &quot;expression&quot;: &quot;`t1`.`b`&quot;</span><br><span class="line">              &#125;</span><br><span class="line">            ],</span><br><span class="line">            &quot;filesort_priority_queue_optimization&quot;: &#123;</span><br><span class="line">              &quot;limit&quot;: <span class="number">3</span>,</span><br><span class="line">              &quot;chosen&quot;: <span class="literal">false</span>,</span><br><span class="line">              &quot;cause&quot;: &quot;sort_is_cheaper&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;filesort_execution&quot;: [</span><br><span class="line">            ],</span><br><span class="line">            &quot;filesort_summary&quot;: &#123;</span><br><span class="line">              &quot;memory_available&quot;: <span class="number">2097152</span>,</span><br><span class="line">              &quot;key_size&quot;: <span class="number">9</span>,</span><br><span class="line">              &quot;row_size&quot;: <span class="number">18</span>,</span><br><span class="line">              &quot;max_rows_per_buffer&quot;: <span class="number">15</span>,</span><br><span class="line">              &quot;num_rows_estimate&quot;: <span class="number">15</span>,</span><br><span class="line">              &quot;num_rows_found&quot;: <span class="number">5</span>,</span><br><span class="line">              &quot;num_initial_chunks_spilled_to_disk&quot;: <span class="number">0</span>,</span><br><span class="line">              &quot;peak_memory_used&quot;: <span class="number">32832</span>,</span><br><span class="line">              &quot;sort_algorithm&quot;: &quot;std::sort&quot;,</span><br><span class="line">              &quot;unpacked_addon_fields&quot;: &quot;skip_heuristic&quot;,</span><br><span class="line">              &quot;sort_mode&quot;: &quot;&lt;fixed_sort_key, additional_fields&gt;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h1 id="4-参考文档"><a href="#4-参考文档" class="headerlink" title="4 参考文档"></a>4 参考文档</h1><p>[1] <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/475410214">庖丁解牛-图解查询分析和调优利器Optimizer Trace</a></p>
<p>[2] <a target="_blank" rel="noopener" href="http://mysql.taobao.org/monthly/2023/07/02/">MySQL·源码分析·索引选择</a></p>
<p>[3] <a target="_blank" rel="noopener" href="https://blog.csdn.net/eddielee9217/article/details/116748751">MySQL OPTIMIZER TRACE 详解</a></p>
<p>[4] <a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/2311852">cost量化分析</a></p>
<p>[5] <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/640558012">「MySQL 8.0」 通过 Optimizer Trace 概览查询优化</a></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/MySQL/" rel="tag"># MySQL</a>
              <a href="/tags/%E5%8A%9F%E8%83%BD%E4%BB%8B%E7%BB%8D/" rel="tag"># 功能介绍</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/11/13/MySQL%E6%8D%89%E8%99%AB%EF%BC%9Aglibc%E5%AF%BC%E8%87%B4mysqld-safe%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8/" rel="prev" title="MySQL捉虫：glibc导致mysqld_safe无法启动">
      <i class="fa fa-chevron-left"></i> MySQL捉虫：glibc导致mysqld_safe无法启动
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-%E5%8A%9F%E8%83%BD%E6%A6%82%E8%BF%B0"><span class="nav-text">1 功能概述</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95"><span class="nav-text">2 使用方法</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-%E8%BE%93%E5%87%BA%E8%A7%A3%E8%AF%BB"><span class="nav-text">3 输出解读</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-join-preparation"><span class="nav-text">3.1 join_preparation</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-1-%E6%B4%BE%E7%94%9F%E8%A1%A8%E5%90%88%E5%B9%B6"><span class="nav-text">3.1.1 派生表合并</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-2-%E6%A0%87%E9%87%8F%E5%AD%90%E6%9F%A5%E8%AF%A2%E7%9B%B4%E6%8E%A5%E6%9B%BF%E4%BB%A3"><span class="nav-text">3.1.2 标量子查询直接替代</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-3-IN%E5%AD%90%E6%9F%A5%E8%AF%A2%E5%8F%98SEMI-JOIN"><span class="nav-text">3.1.3 IN子查询变SEMI-JOIN</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-4-EXISTS%E5%AD%90%E6%9F%A5%E8%AF%A2%E5%8F%98SEMI-JOIN"><span class="nav-text">3.1.4 EXISTS子查询变SEMI-JOIN</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-5-%E5%AD%90%E6%9F%A5%E8%AF%A2IN%E5%88%B0EXISTS"><span class="nav-text">3.1.5 子查询IN到EXISTS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-6-%E8%BD%AC%E6%8D%A2%E7%9A%84%E6%A0%87%E9%87%8F%E5%AD%90%E6%9F%A5%E8%AF%A2%E8%BD%AC%E6%8D%A2%E6%88%90Derived-Table"><span class="nav-text">3.1.6 转换的标量子查询转换成Derived Table</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-7-SEMI-JOIN%E8%BD%AC%E6%8D%A2%E4%B8%BANESTED-JOIN"><span class="nav-text">3.1.7 SEMI-JOIN转换为NESTED-JOIN</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-join-optimization"><span class="nav-text">3.2 join_optimization</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-1%E8%A1%A8%E8%AE%BF%E9%97%AE%E6%96%B9%E5%BC%8F"><span class="nav-text">3.2.1表访问方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-2-condition-processing"><span class="nav-text">3.2.2 condition_processing</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-3-substitute-generated-columns"><span class="nav-text">3.2.3 substitute_generated_columns</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-4-table-dependencies"><span class="nav-text">3.2.4 table_dependencies</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-5-ref-optimizer-key-uses"><span class="nav-text">3.2.5 ref_optimizer_key_uses</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-6-pulled-out-semijoin-tables"><span class="nav-text">3.2.6 pulled_out_semijoin_tables</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-7-rows-estimation"><span class="nav-text">3.2.7 rows_estimation</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-8-execution-plan-for-potential-materialization"><span class="nav-text">3.2.8 execution_plan_for_potential_materialization</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-9-considered-execution-plans"><span class="nav-text">3.2.9 considered_execution_plans</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-10-creating-tmp-table"><span class="nav-text">3.2.10 creating_tmp_table</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-11-attaching-conditions-to-tables"><span class="nav-text">3.2.11 attaching_conditions_to_tables</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-12-optimizing-distinct-group-by-order-by"><span class="nav-text">3.2.12 optimizing_distinct_group_by_order_by</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-13-reconsidering-access-paths-for-index-ordering"><span class="nav-text">3.2.13 reconsidering_access_paths_for_index_ordering</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-14-finalizing-table-conditions"><span class="nav-text">3.2.14 finalizing_table_conditions</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-15-refine-plan"><span class="nav-text">3.2.15 refine_plan</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-16-considering-tmp-tables"><span class="nav-text">3.2.16 considering_tmp_tables</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-3-join-execution"><span class="nav-text">3.3 join_execution</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-1-%E4%B8%B4%E6%97%B6%E8%A1%A8%E4%BF%A1%E6%81%AF"><span class="nav-text">3.3.1 临时表信息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-2-%E6%8E%92%E5%BA%8F%E4%BF%A1%E6%81%AF"><span class="nav-text">3.3.2 排序信息</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-%E5%8F%82%E8%80%83%E6%96%87%E6%A1%A3"><span class="nav-text">4 参考文档</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="lemonacy"
      src="/uploads/avatar.jpg">
  <p class="site-author-name" itemprop="name">lemonacy</p>
  <div class="site-description" itemprop="description">Make Lemons into Lemonade</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">5</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="mailto:licy0304@163.com" title="E-Mail → mailto:licy0304@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">lemonacy</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  











<script>
document.querySelectorAll('.pdfobject-container').forEach(element => {
  let url = element.dataset.target;
  let pdfOpenParams = {
    navpanes : 0,
    toolbar  : 0,
    statusbar: 0,
    pagemode : 'thumbs',
    view     : 'FitH'
  };
  let pdfOpenFragment = '#' + Object.entries(pdfOpenParams).map(([key, value]) => `${key}=${encodeURIComponent(value)}`).join('&');
  let fullURL = `/lib/pdf/web/viewer.html?file=${encodeURIComponent(url)}${pdfOpenFragment}`;

  if (NexT.utils.supportsPDFs()) {
    element.innerHTML = `<embed class="pdfobject" src="${url + pdfOpenFragment}" type="application/pdf" style="height: ${element.dataset.height};">`;
  } else {
    element.innerHTML = `<iframe src="${fullURL}" style="height: ${element.dataset.height};" frameborder="0"></iframe>`;
  }
});
</script>




  

  

</body>
</html>
